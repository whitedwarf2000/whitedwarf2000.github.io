{"version":3,"sources":["ArrowKeyStepper/ArrowKeyStepper.module.css","vendor/detectElementResize.js","demo/ContentBox.js","ArrowKeyStepper/ArrowKeyStepper.js","AutoSizer/AutoSizer.js","Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js","Grid/utils/CellSizeAndPositionManager.js","Grid/utils/maxElementSize.js","Grid/utils/ScalingCellSizeAndPositionManager.js","utils/createCallbackMemoizer.js","Grid/utils/updateScrollIndexHelper.js","utils/animationFrame.js","utils/requestAnimationTimeout.js","Grid/Grid.js","Grid/defaultOverscanIndicesGetter.js","Grid/defaultCellRangeRenderer.js","ArrowKeyStepper/ArrowKeyStepper.example.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","createDetectElementResize","nonce","hostWindow","_window","attachEvent","window","self","global","document","requestFrame","raf","requestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","fn","setTimeout","cancelFrame","cancel","cancelAnimationFrame","mozCancelAnimationFrame","webkitCancelAnimationFrame","clearTimeout","id","resetTriggers","element","triggers","__resizeTriggers__","expand","firstElementChild","contract","lastElementChild","expandChild","scrollLeft","scrollWidth","scrollTop","scrollHeight","style","width","offsetWidth","height","offsetHeight","scrollListener","e","target","className","indexOf","this","__resizeRAF__","__resizeLast__","checkTriggers","__resizeListeners__","forEach","call","animation","keyframeprefix","animationstartevent","domPrefixes","split","startEvents","elm","createElement","undefined","animationName","i","length","toLowerCase","animationKeyframes","animationStyle","addResizeListener","doc","ownerDocument","elementStyle","getComputedStyle","position","getElementById","css","head","getElementsByTagName","type","setAttribute","styleSheet","cssText","appendChild","createTextNode","createStyles","innerHTML","addEventListener","__animationListener__","push","removeResizeListener","detachEvent","splice","removeEventListener","removeChild","ContentBox","children","clsx","styles","ContentBoxHeader","text","sourceLink","docsLink","links","Link","href","key","Header","Small","ContentBoxParagraph","Paragraph","ArrowKeyStepper","state","scrollToColumn","scrollToRow","instanceProps","prevScrollToColumn","prevScrollToRow","_columnStartIndex","_columnStopIndex","_rowStartIndex","_rowStopIndex","_onKeyDown","event","props","columnCount","disabled","mode","rowCount","_getScrollState","scrollToColumnPrevious","scrollToRowPrevious","Math","min","max","preventDefault","_updateScrollState","_onSectionRendered","columnStartIndex","columnStopIndex","rowStartIndex","rowStopIndex","setState","onMouseUp","onKeyDown","onSectionRendered","isControlled","onScrollToChange","nextProps","prevState","React","defaultProps","polyfill","AutoSizer","defaultHeight","defaultWidth","_onResize","disableHeight","disableWidth","onResize","_parentNode","paddingLeft","parseInt","paddingRight","paddingTop","paddingBottom","newHeight","newWidth","_setRef","autoSizer","_autoSizer","parentNode","defaultView","HTMLElement","_detectElementResize","outerStyle","overflow","childParams","ref","calculateSizeAndPositionDataAndUpdateScrollOffset","cellCount","cellSize","computeMetadataCallback","computeMetadataCallbackProps","nextCellsCount","nextCellSize","nextScrollToIndex","scrollToIndex","updateScrollOffsetForScrollToIndex","CellSizeAndPositionManager","cellSizeGetter","estimatedCellSize","_cellSizeAndPositionData","_lastMeasuredIndex","_lastBatchedIndex","_cellSizeGetter","_cellCount","_estimatedCellSize","index","Error","lastMeasuredCellSizeAndPosition","getSizeAndPositionOfLastMeasuredCell","offset","size","isNaN","align","containerSize","currentOffset","targetIndex","idealOffset","datum","getSizeAndPositionOfCell","maxOffset","minOffset","totalSize","getTotalSize","params","start","_findNearestCell","stop","high","low","middle","floor","interval","_binarySearch","lastMeasuredIndex","_exponentialSearch","getMaxElementSize","chrome","ScalingCellSizeAndPositionManager","maxScrollSize","_cellSizeAndPositionManager","_maxScrollSize","configure","getCellCount","getEstimatedCellSize","getLastMeasuredIndex","safeTotalSize","offsetPercentage","_getOffsetPercentage","round","_safeOffsetToOffset","getUpdatedOffsetForIndex","_offsetToSafeOffset","getVisibleCellRange","resetCell","createCallbackMemoizer","requireAllKeys","cachedIndices","callback","indices","keys","Object","allInitialized","every","value","Array","isArray","indexChanged","some","cachedValue","join","updateScrollIndexHelper","cellSizeAndPositionManager","previousCellsCount","previousCellSize","previousScrollToAlignment","previousScrollToIndex","previousSize","scrollOffset","scrollToAlignment","sizeJustIncreasedFromZero","updateScrollIndexCallback","hasScrollToIndex","win","request","oRequestAnimationFrame","msRequestAnimationFrame","oCancelAnimationFrame","msCancelAnimationFrame","caf","cancelAnimationTimeout","frame","SCROLL_POSITION_CHANGE_REASONS","Grid","_onGridRenderedMemoizer","_onScrollMemoizer","_deferredInvalidateColumnIndex","_deferredInvalidateRowIndex","_recomputeScrollLeftFlag","_recomputeScrollTopFlag","_horizontalScrollBarSize","_verticalScrollBarSize","_scrollbarPresenceChanged","_renderedColumnStartIndex","_renderedColumnStopIndex","_renderedRowStartIndex","_renderedRowStopIndex","_styleCache","_cellCache","_debounceScrollEndedCallback","_disablePointerEventsTimeoutId","isScrolling","needToResetStyleCache","_invokeOnGridRenderedHelper","columnOverscanStartIndex","columnOverscanStopIndex","rowOverscanStartIndex","rowOverscanStopIndex","_setScrollingContainerRef","_scrollingContainer","_onScroll","handleScrollEvent","columnSizeAndPositionManager","_wrapSizeGetter","columnWidth","_getEstimatedColumnSize","rowSizeAndPositionManager","rowHeight","_getEstimatedRowSize","prevColumnWidth","prevRowHeight","prevColumnCount","prevRowCount","prevIsScrolling","scrollbarSize","scrollbarSizeMeasured","scrollDirectionHorizontal","scrollDirectionVertical","scrollPositionChangeReason","_initialScrollTop","_getCalculatedScrollTop","_initialScrollLeft","_getCalculatedScrollLeft","alignment","columnIndex","rowIndex","offsetProps","scrollLeftParam","scrollTopParam","_debounceScrollEnded","autoHeight","autoWidth","totalRowsHeight","totalColumnsWidth","newState","_invokeOnScrollMemoizer","forceUpdate","_updateScrollLeftForScrollToColumn","_updateScrollTopForScrollToRow","getScrollbarSize","_handleInvalidatedGridSize","stateUpdate","_getScrollToPositionStateUpdate","sizeIsBiggerThanZero","_maybeCallOnScrollbarPresenceChange","prevProps","columnOrRowCountJustIncreasedFromZero","autoContainerWidth","containerProps","containerRole","containerStyle","noContentRenderer","role","tabIndex","_isScrolling","gridStyle","boxSizing","direction","WebkitOverflowScrolling","willChange","_resetStyleCache","_calculateChildrenToRender","verticalScrollBarSize","horizontalScrollBarSize","overflowX","overflowY","childrenToDisplay","_childrenToDisplay","showNoContentRenderer","aria-label","aria-readonly","onScroll","maxWidth","maxHeight","pointerEvents","cellRenderer","cellRangeRenderer","deferredMeasurementCache","overscanColumnCount","overscanIndicesGetter","overscanRowCount","isScrollingOptOut","visibleColumnIndices","visibleRowIndices","horizontalOffsetAdjustment","getOffsetAdjustment","verticalOffsetAdjustment","overscanColumnIndices","overscanCellsCount","scrollDirection","startIndex","stopIndex","overscanRowIndices","overscanStartIndex","overscanStopIndex","hasFixedHeight","has","hasFixedWidth","cellCache","parent","styleCache","scrollingResetTimeInterval","delay","Promise","resolve","then","Date","now","timeout","requestAnimationTimeout","recomputeGridSize","clientHeight","clientWidth","hasOwnProperty","Boolean","onScrollbarPresenceChange","horizontal","vertical","_getScrollLeftForScrollToColumnStateUpdate","_getScrollTopForScrollToRowStateUpdate","assign","maybeStateA","maybeStateB","estimatedColumnSize","estimatedRowSize","finalColumn","scrollBarSize","calculatedScrollLeft","finalRow","calculatedScrollTop","renderedCells","areOffsetsAdjusted","canCacheStyle","rowDatum","columnDatum","isVisible","left","top","cellRendererParams","renderedCell","ArrowKeyStepperExample","isMouseDown","isClickable","startCellIndex","startRowIndex","selectedItems","selectTo","rowStart","rowEnd","cellStart","cellEnd","result","j","r","c","handleMouseUp","mouseDown","button","mouseOver","_getColumnWidth","_getRowHeight","compare","item","_cellRenderer","Cell","FocusedCell","selected","onMouseDown","onMouseOver","onClick","_selectCell","App","textAlign","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.fc5d7c25.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"Grid\":\"ArrowKeyStepper_Grid__1ZL-A\",\"Cell\":\"ArrowKeyStepper_Cell__rkdPy\",\"FocusedCell\":\"ArrowKeyStepper_FocusedCell__22QMQ\",\"Radio\":\"ArrowKeyStepper_Radio__271VN\",\"checkboxLabel\":\"ArrowKeyStepper_checkboxLabel__uIDhN\",\"checkbox\":\"ArrowKeyStepper_checkbox__3cJjV\",\"selected\":\"ArrowKeyStepper_selected__2L6-b\"};","/**\r\n * Detect Element Resize.\r\n * https://github.com/sdecima/javascript-detect-element-resize\r\n * Sebastian Decima\r\n *\r\n * Forked from version 0.5.3; includes the following modifications:\r\n * 1) Guard against unsafe 'window' and 'document' references (to support SSR).\r\n * 2) Defer initialization code via a top-level function wrapper (to support SSR).\r\n * 3) Avoid unnecessary reflows by not measuring size for scroll events bubbling from children.\r\n * 4) Add nonce for style element.\r\n * 5) Added support for injecting custom window object\r\n **/\r\n\r\nexport default function createDetectElementResize(nonce, hostWindow) {\r\n  // Check `document` and `window` in case of server-side rendering\r\n  var _window;\r\n  if (typeof hostWindow !== 'undefined') {\r\n    _window = hostWindow;\r\n  } else if (typeof window !== 'undefined') {\r\n    _window = window;\r\n  } else if (typeof window.self !== 'undefined') {\r\n    _window = window.self;\r\n  } else {\r\n    _window = global;\r\n  }\r\n\r\n  var attachEvent =\r\n    typeof _window.document !== 'undefined' && _window.document.attachEvent;\r\n\r\n  if (!attachEvent) {\r\n    var requestFrame = (function() {\r\n      var raf =\r\n        _window.requestAnimationFrame ||\r\n        _window.mozRequestAnimationFrame ||\r\n        _window.webkitRequestAnimationFrame ||\r\n        function(fn) {\r\n          return _window.setTimeout(fn, 20);\r\n        };\r\n      return function(fn) {\r\n        return raf(fn);\r\n      };\r\n    })();\r\n\r\n    var cancelFrame = (function() {\r\n      var cancel =\r\n        _window.cancelAnimationFrame ||\r\n        _window.mozCancelAnimationFrame ||\r\n        _window.webkitCancelAnimationFrame ||\r\n        _window.clearTimeout;\r\n      return function(id) {\r\n        return cancel(id);\r\n      };\r\n    })();\r\n\r\n    var resetTriggers = function(element) {\r\n      var triggers = element.__resizeTriggers__,\r\n        expand = triggers.firstElementChild,\r\n        contract = triggers.lastElementChild,\r\n        expandChild = expand.firstElementChild;\r\n      contract.scrollLeft = contract.scrollWidth;\r\n      contract.scrollTop = contract.scrollHeight;\r\n      expandChild.style.width = expand.offsetWidth + 1 + 'px';\r\n      expandChild.style.height = expand.offsetHeight + 1 + 'px';\r\n      expand.scrollLeft = expand.scrollWidth;\r\n      expand.scrollTop = expand.scrollHeight;\r\n    };\r\n\r\n    var checkTriggers = function(element) {\r\n      return (\r\n        element.offsetWidth != element.__resizeLast__.width ||\r\n        element.offsetHeight != element.__resizeLast__.height\r\n      );\r\n    };\r\n\r\n    var scrollListener = function(e) {\r\n      // Don't measure (which forces) reflow for scrolls that happen inside of children!\r\n      if (\r\n        e.target.className &&\r\n        typeof e.target.className.indexOf === 'function' &&\r\n        e.target.className.indexOf('contract-trigger') < 0 &&\r\n        e.target.className.indexOf('expand-trigger') < 0\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      var element = this;\r\n      resetTriggers(this);\r\n      if (this.__resizeRAF__) {\r\n        cancelFrame(this.__resizeRAF__);\r\n      }\r\n      this.__resizeRAF__ = requestFrame(function() {\r\n        if (checkTriggers(element)) {\r\n          element.__resizeLast__.width = element.offsetWidth;\r\n          element.__resizeLast__.height = element.offsetHeight;\r\n          element.__resizeListeners__.forEach(function(fn) {\r\n            fn.call(element, e);\r\n          });\r\n        }\r\n      });\r\n    };\r\n\r\n    /* Detect CSS Animations support to detect element display/re-attach */\r\n    var animation = false,\r\n      keyframeprefix = '',\r\n      animationstartevent = 'animationstart',\r\n      domPrefixes = 'Webkit Moz O ms'.split(' '),\r\n      startEvents = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(\r\n        ' ',\r\n      ),\r\n      pfx = '';\r\n    {\r\n      var elm = _window.document.createElement('fakeelement');\r\n      if (elm.style.animationName !== undefined) {\r\n        animation = true;\r\n      }\r\n\r\n      if (animation === false) {\r\n        for (var i = 0; i < domPrefixes.length; i++) {\r\n          if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {\r\n            pfx = domPrefixes[i];\r\n            keyframeprefix = '-' + pfx.toLowerCase() + '-';\r\n            animationstartevent = startEvents[i];\r\n            animation = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    var animationName = 'resizeanim';\r\n    var animationKeyframes =\r\n      '@' +\r\n      keyframeprefix +\r\n      'keyframes ' +\r\n      animationName +\r\n      ' { from { opacity: 0; } to { opacity: 0; } } ';\r\n    var animationStyle =\r\n      keyframeprefix + 'animation: 1ms ' + animationName + '; ';\r\n  }\r\n\r\n  var createStyles = function(doc) {\r\n    if (!doc.getElementById('detectElementResize')) {\r\n      //opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360\r\n      var css =\r\n          (animationKeyframes ? animationKeyframes : '') +\r\n          '.resize-triggers { ' +\r\n          (animationStyle ? animationStyle : '') +\r\n          'visibility: hidden; opacity: 0; } ' +\r\n          '.resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \" \"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',\r\n        head = doc.head || doc.getElementsByTagName('head')[0],\r\n        style = doc.createElement('style');\r\n\r\n      style.id = 'detectElementResize';\r\n      style.type = 'text/css';\r\n\r\n      if (nonce != null) {\r\n        style.setAttribute('nonce', nonce);\r\n      }\r\n\r\n      if (style.styleSheet) {\r\n        style.styleSheet.cssText = css;\r\n      } else {\r\n        style.appendChild(doc.createTextNode(css));\r\n      }\r\n\r\n      head.appendChild(style);\r\n    }\r\n  };\r\n\r\n  var addResizeListener = function(element, fn) {\r\n    if (attachEvent) {\r\n      element.attachEvent('onresize', fn);\r\n    } else {\r\n      if (!element.__resizeTriggers__) {\r\n        var doc = element.ownerDocument;\r\n        var elementStyle = _window.getComputedStyle(element);\r\n        if (elementStyle && elementStyle.position == 'static') {\r\n          element.style.position = 'relative';\r\n        }\r\n        createStyles(doc);\r\n        element.__resizeLast__ = {};\r\n        element.__resizeListeners__ = [];\r\n        (element.__resizeTriggers__ = doc.createElement('div')).className =\r\n          'resize-triggers';\r\n        element.__resizeTriggers__.innerHTML =\r\n          '<div class=\"expand-trigger\"><div></div></div>' +\r\n          '<div class=\"contract-trigger\"></div>';\r\n        element.appendChild(element.__resizeTriggers__);\r\n        resetTriggers(element);\r\n        element.addEventListener('scroll', scrollListener, true);\r\n\r\n        /* Listen for a css animation to detect element display/re-attach */\r\n        if (animationstartevent) {\r\n          element.__resizeTriggers__.__animationListener__ = function animationListener(\r\n            e,\r\n          ) {\r\n            if (e.animationName == animationName) {\r\n              resetTriggers(element);\r\n            }\r\n          };\r\n          element.__resizeTriggers__.addEventListener(\r\n            animationstartevent,\r\n            element.__resizeTriggers__.__animationListener__,\r\n          );\r\n        }\r\n      }\r\n      element.__resizeListeners__.push(fn);\r\n    }\r\n  };\r\n\r\n  var removeResizeListener = function(element, fn) {\r\n    if (attachEvent) {\r\n      element.detachEvent('onresize', fn);\r\n    } else {\r\n      element.__resizeListeners__.splice(\r\n        element.__resizeListeners__.indexOf(fn),\r\n        1,\r\n      );\r\n      if (!element.__resizeListeners__.length) {\r\n        element.removeEventListener('scroll', scrollListener, true);\r\n        if (element.__resizeTriggers__.__animationListener__) {\r\n          element.__resizeTriggers__.removeEventListener(\r\n            animationstartevent,\r\n            element.__resizeTriggers__.__animationListener__,\r\n          );\r\n          element.__resizeTriggers__.__animationListener__ = null;\r\n        }\r\n        try {\r\n          element.__resizeTriggers__ = !element.removeChild(\r\n            element.__resizeTriggers__,\r\n          );\r\n        } catch (e) {\r\n          // Preact compat; see developit/preact-compat/issues/228\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  return {\r\n    addResizeListener,\r\n    removeResizeListener,\r\n  };\r\n}\r\n","import * as React from 'react';\r\nimport clsx from 'clsx';\r\nimport styles from './ContentBox.css';\r\n\r\nexport function ContentBox({className, children, style}) {\r\n  return (\r\n    <div className={clsx(styles.ContentBox, className)} style={style}>\r\n      {children}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport function ContentBoxHeader({text, sourceLink, docsLink}) {\r\n  const links = [];\r\n\r\n  if (sourceLink) {\r\n    links.push(\r\n      <a className={styles.Link} href={sourceLink} key=\"sourceLink\">\r\n        Source\r\n      </a>,\r\n    );\r\n  }\r\n\r\n  if (sourceLink && docsLink) {\r\n    links.push(<span key=\"separator\"> | </span>);\r\n  }\r\n\r\n  if (docsLink) {\r\n    links.push(\r\n      <a className={styles.Link} href={docsLink} key=\"docsLink\">\r\n        Docs\r\n      </a>,\r\n    );\r\n  }\r\n\r\n  return (\r\n    <h1 className={styles.Header}>\r\n      {text}\r\n\r\n      {links.length > 0 && <small className={styles.Small}>{links}</small>}\r\n    </h1>\r\n  );\r\n}\r\n\r\nexport function ContentBoxParagraph({children}) {\r\n  return <div className={styles.Paragraph}>{children}</div>;\r\n}\r\n","import * as React from \"react\";\r\nimport { polyfill } from \"react-lifecycles-compat\";\r\n\r\nclass ArrowKeyStepper extends React.PureComponent {\r\n  static defaultProps = {\r\n    disabled: false,\r\n    isControlled: false,\r\n    mode: \"edges\",\r\n    scrollToColumn: 0,\r\n    scrollToRow: 0\r\n  };\r\n\r\n  state = {\r\n    scrollToColumn: 0,\r\n    scrollToRow: 0,\r\n    instanceProps: {\r\n      prevScrollToColumn: 0,\r\n      prevScrollToRow: 0\r\n    }\r\n  };\r\n\r\n  _columnStartIndex = 0;\r\n  _columnStopIndex = 0;\r\n  _rowStartIndex = 0;\r\n  _rowStopIndex = 0;\r\n\r\n  static getDerivedStateFromProps(nextProps, prevState) {\r\n    if (nextProps.isControlled) {\r\n      return {};\r\n    }\r\n\r\n    if (\r\n      nextProps.scrollToColumn !== prevState.instanceProps.prevScrollToColumn ||\r\n      nextProps.scrollToRow !== prevState.instanceProps.prevScrollToRow\r\n    ) {\r\n      return {\r\n        ...prevState,\r\n        scrollToColumn: nextProps.scrollToColumn,\r\n        scrollToRow: nextProps.scrollToRow,\r\n        instanceProps: {\r\n          prevScrollToColumn: nextProps.scrollToColumn,\r\n          prevScrollToRow: nextProps.scrollToRow\r\n        }\r\n      };\r\n    }\r\n\r\n    return {};\r\n  }\r\n\r\n  setScrollIndexes({ scrollToColumn, scrollToRow }) {\r\n    this.setState({\r\n      scrollToRow,\r\n      scrollToColumn\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const { className, children, onMouseUp } = this.props;\r\n    const { scrollToColumn, scrollToRow } = this._getScrollState();\r\n\r\n    return (\r\n      <div className={className} onKeyDown={this._onKeyDown} onMouseUp={onMouseUp}>\r\n        {children({\r\n          onSectionRendered: this._onSectionRendered,\r\n          scrollToColumn,\r\n          scrollToRow\r\n        })}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  _onKeyDown = event => {\r\n    const { columnCount, disabled, mode, rowCount } = this.props;\r\n\r\n    if (disabled) {\r\n      return;\r\n    }\r\n\r\n    const {\r\n      scrollToColumn: scrollToColumnPrevious,\r\n      scrollToRow: scrollToRowPrevious\r\n    } = this._getScrollState();\r\n\r\n    let { scrollToColumn, scrollToRow } = this._getScrollState();\r\n\r\n    // The above cases all prevent default event event behavior.\r\n    // This is to keep the grid from scrolling after the snap-to update.\r\n    switch (event.key) {\r\n      case \"ArrowDown\":\r\n        scrollToRow =\r\n          mode === \"cells\"\r\n            ? Math.min(scrollToRow + 1, rowCount - 1)\r\n            : Math.min(this._rowStopIndex + 1, rowCount - 1);\r\n        break;\r\n      case \"ArrowLeft\":\r\n        scrollToColumn =\r\n          mode === \"cells\"\r\n            ? Math.max(scrollToColumn - 1, 0)\r\n            : Math.max(this._columnStartIndex - 1, 0);\r\n        break;\r\n      case \"ArrowRight\":\r\n        scrollToColumn =\r\n          mode === \"cells\"\r\n            ? Math.min(scrollToColumn + 1, columnCount - 1)\r\n            : Math.min(this._columnStopIndex + 1, columnCount - 1);\r\n        break;\r\n      case \"ArrowUp\":\r\n        scrollToRow =\r\n          mode === \"cells\"\r\n            ? Math.max(scrollToRow - 1, 0)\r\n            : Math.max(this._rowStartIndex - 1, 0);\r\n        break;\r\n    }\r\n\r\n    if (\r\n      scrollToColumn !== scrollToColumnPrevious ||\r\n      scrollToRow !== scrollToRowPrevious\r\n    ) {\r\n      event.preventDefault();\r\n\r\n      this._updateScrollState({ scrollToColumn, scrollToRow });\r\n    }\r\n  };\r\n\r\n  _onSectionRendered = ({\r\n    columnStartIndex,\r\n    columnStopIndex,\r\n    rowStartIndex,\r\n    rowStopIndex\r\n  }) => {\r\n    this._columnStartIndex = columnStartIndex;\r\n    this._columnStopIndex = columnStopIndex;\r\n    this._rowStartIndex = rowStartIndex;\r\n    this._rowStopIndex = rowStopIndex;\r\n  };\r\n\r\n  _getScrollState() {\r\n    return this.props.isControlled ? this.props : this.state;\r\n  }\r\n\r\n  _updateScrollState({ scrollToColumn, scrollToRow }) {\r\n    const { isControlled, onScrollToChange } = this.props;\r\n\r\n    if (typeof onScrollToChange === \"function\") {\r\n      onScrollToChange({ scrollToColumn, scrollToRow });\r\n    }\r\n\r\n    if (!isControlled) {\r\n      this.setState({ scrollToColumn, scrollToRow });\r\n    }\r\n  }\r\n}\r\n\r\npolyfill(ArrowKeyStepper);\r\n\r\nexport default ArrowKeyStepper;\r\n","import * as React from \"react\";\r\nimport createDetectElementResize from \"../vendor/detectElementResize\";\r\n\r\nexport default class AutoSizer extends React.Component {\r\n  static defaultProps = {\r\n    onResize: () => {},\r\n    disableHeight: false,\r\n    disableWidth: false,\r\n    style: {}\r\n  };\r\n\r\n  state = {\r\n    height: this.props.defaultHeight || 0,\r\n    width: this.props.defaultWidth || 0\r\n  };\r\n\r\n  _parentNode;\r\n  _autoSizer;\r\n  _window; // uses any instead of Window because Flow doesn't have window type\r\n  _detectElementResize;\r\n\r\n  componentDidMount() {\r\n    const { nonce } = this.props;\r\n    if (\r\n      this._autoSizer &&\r\n      this._autoSizer.parentNode &&\r\n      this._autoSizer.parentNode.ownerDocument &&\r\n      this._autoSizer.parentNode.ownerDocument.defaultView &&\r\n      this._autoSizer.parentNode instanceof\r\n        this._autoSizer.parentNode.ownerDocument.defaultView.HTMLElement\r\n    ) {\r\n      // Delay access of parentNode until mount.\r\n      // This handles edge-cases where the component has already been unmounted before its ref has been set,\r\n      // As well as libraries like react-lite which have a slightly different lifecycle.\r\n      this._parentNode = this._autoSizer.parentNode;\r\n      this._window = this._autoSizer.parentNode.ownerDocument.defaultView;\r\n\r\n      // Defer requiring resize handler in order to support server-side rendering.\r\n      // See issue #41\r\n      this._detectElementResize = createDetectElementResize(\r\n        nonce,\r\n        this._window\r\n      );\r\n      this._detectElementResize.addResizeListener(\r\n        this._parentNode,\r\n        this._onResize\r\n      );\r\n\r\n      this._onResize();\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    if (this._detectElementResize && this._parentNode) {\r\n      this._detectElementResize.removeResizeListener(\r\n        this._parentNode,\r\n        this._onResize\r\n      );\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const {\r\n      children,\r\n      className,\r\n      disableHeight,\r\n      disableWidth,\r\n      style\r\n    } = this.props;\r\n    const { height, width } = this.state;\r\n\r\n    // Outer div should not force width/height since that may prevent containers from shrinking.\r\n    // Inner component should overflow and use calculated width/height.\r\n    // See issue #68 for more information.\r\n    const outerStyle = { overflow: \"visible\" };\r\n    const childParams = {};\r\n\r\n    if (!disableHeight) {\r\n      outerStyle.height = 0;\r\n      childParams.height = height;\r\n    }\r\n\r\n    if (!disableWidth) {\r\n      outerStyle.width = 0;\r\n      childParams.width = width;\r\n    }\r\n\r\n    return (\r\n      <div\r\n        className={className}\r\n        ref={this._setRef}\r\n        style={{\r\n          ...outerStyle,\r\n          ...style\r\n        }}\r\n      >\r\n        {children(childParams)}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  _onResize = () => {\r\n    const { disableHeight, disableWidth, onResize } = this.props;\r\n\r\n    if (this._parentNode) {\r\n      // Guard against AutoSizer component being removed from the DOM immediately after being added.\r\n      // This can result in invalid style values which can result in NaN values if we don't handle them.\r\n      // See issue #150 for more context.\r\n\r\n      const height = this._parentNode.offsetHeight || 0;\r\n      const width = this._parentNode.offsetWidth || 0;\r\n\r\n      const win = this._window || window;\r\n      const style = win.getComputedStyle(this._parentNode) || {};\r\n      const paddingLeft = parseInt(style.paddingLeft, 10) || 0;\r\n      const paddingRight = parseInt(style.paddingRight, 10) || 0;\r\n      const paddingTop = parseInt(style.paddingTop, 10) || 0;\r\n      const paddingBottom = parseInt(style.paddingBottom, 10) || 0;\r\n\r\n      const newHeight = height - paddingTop - paddingBottom;\r\n      const newWidth = width - paddingLeft - paddingRight;\r\n\r\n      if (\r\n        (!disableHeight && this.state.height !== newHeight) ||\r\n        (!disableWidth && this.state.width !== newWidth)\r\n      ) {\r\n        this.setState({\r\n          height: height - paddingTop - paddingBottom,\r\n          width: width - paddingLeft - paddingRight\r\n        });\r\n\r\n        onResize({ height, width });\r\n      }\r\n    }\r\n  };\r\n\r\n  _setRef = autoSizer => {\r\n    this._autoSizer = autoSizer;\r\n  };\r\n}\r\n","// @flow\r\n\r\n/**\r\n * Helper method that determines when to recalculate row or column metadata.\r\n */\r\n\r\ntype Params<T> = {\r\n  // Number of rows or columns in the current axis\r\n  cellCount: number,\r\n\r\n  // Width or height of cells for the current axis\r\n  cellSize: ?number,\r\n\r\n  // Method to invoke if cell metadata should be recalculated\r\n  computeMetadataCallback: (props: T) => void,\r\n\r\n  // Parameters to pass to :computeMetadataCallback\r\n  computeMetadataCallbackProps: T,\r\n\r\n  // Newly updated number of rows or columns in the current axis\r\n  nextCellsCount: number,\r\n\r\n  // Newly updated width or height of cells for the current axis\r\n  nextCellSize: ?number,\r\n\r\n  // Newly updated scroll-to-index\r\n  nextScrollToIndex: number,\r\n\r\n  // Scroll-to-index\r\n  scrollToIndex: number,\r\n\r\n  // Callback to invoke if the scroll position should be recalculated\r\n  updateScrollOffsetForScrollToIndex: () => void,\r\n};\r\n\r\nexport default function calculateSizeAndPositionDataAndUpdateScrollOffset({\r\n  cellCount,\r\n  cellSize,\r\n  computeMetadataCallback,\r\n  computeMetadataCallbackProps,\r\n  nextCellsCount,\r\n  nextCellSize,\r\n  nextScrollToIndex,\r\n  scrollToIndex,\r\n  updateScrollOffsetForScrollToIndex,\r\n}: Params<*>) {\r\n  // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.\r\n  // In that event users should use the manual recompute methods to inform of changes.\r\n  if (\r\n    cellCount !== nextCellsCount ||\r\n    ((typeof cellSize === 'number' || typeof nextCellSize === 'number') &&\r\n      cellSize !== nextCellSize)\r\n  ) {\r\n    computeMetadataCallback(computeMetadataCallbackProps);\r\n\r\n    // Updated cell metadata may have hidden the previous scrolled-to item.\r\n    // In this case we should also update the scrollTop to ensure it stays visible.\r\n    if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {\r\n      updateScrollOffsetForScrollToIndex();\r\n    }\r\n  }\r\n}\r\n","/** @flow */\r\n\r\nimport type {Alignment, CellSizeGetter, VisibleCellRange} from '../types';\r\n\r\ntype CellSizeAndPositionManagerParams = {\r\n  cellCount: number,\r\n  cellSizeGetter: CellSizeGetter,\r\n  estimatedCellSize: number,\r\n};\r\n\r\ntype ConfigureParams = {\r\n  cellCount: number,\r\n  estimatedCellSize: number,\r\n  cellSizeGetter: CellSizeGetter,\r\n};\r\n\r\ntype GetUpdatedOffsetForIndex = {\r\n  align: Alignment,\r\n  containerSize: number,\r\n  currentOffset: number,\r\n  targetIndex: number,\r\n};\r\n\r\ntype GetVisibleCellRangeParams = {\r\n  containerSize: number,\r\n  offset: number,\r\n};\r\n\r\ntype SizeAndPositionData = {\r\n  offset: number,\r\n  size: number,\r\n};\r\n\r\n/**\r\n * Just-in-time calculates and caches size and position information for a collection of cells.\r\n */\r\n\r\nexport default class CellSizeAndPositionManager {\r\n  // Cache of size and position data for cells, mapped by cell index.\r\n  // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex\r\n  _cellSizeAndPositionData = {};\r\n\r\n  // Measurements for cells up to this index can be trusted; cells afterward should be estimated.\r\n  _lastMeasuredIndex = -1;\r\n\r\n  // Used in deferred mode to track which cells have been queued for measurement.\r\n  _lastBatchedIndex = -1;\r\n\r\n  _cellCount: number;\r\n  _cellSizeGetter: CellSizeGetter;\r\n  _estimatedCellSize: number;\r\n\r\n  constructor({\r\n    cellCount,\r\n    cellSizeGetter,\r\n    estimatedCellSize,\r\n  }: CellSizeAndPositionManagerParams) {\r\n    this._cellSizeGetter = cellSizeGetter;\r\n    this._cellCount = cellCount;\r\n    this._estimatedCellSize = estimatedCellSize;\r\n  }\r\n\r\n  areOffsetsAdjusted() {\r\n    return false;\r\n  }\r\n\r\n  configure({cellCount, estimatedCellSize, cellSizeGetter}: ConfigureParams) {\r\n    this._cellCount = cellCount;\r\n    this._estimatedCellSize = estimatedCellSize;\r\n    this._cellSizeGetter = cellSizeGetter;\r\n  }\r\n\r\n  getCellCount(): number {\r\n    return this._cellCount;\r\n  }\r\n\r\n  getEstimatedCellSize(): number {\r\n    return this._estimatedCellSize;\r\n  }\r\n\r\n  getLastMeasuredIndex(): number {\r\n    return this._lastMeasuredIndex;\r\n  }\r\n\r\n  getOffsetAdjustment() {\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * This method returns the size and position for the cell at the specified index.\r\n   * It just-in-time calculates (or used cached values) for cells leading up to the index.\r\n   */\r\n  getSizeAndPositionOfCell(index: number): SizeAndPositionData {\r\n    if (index < 0 || index >= this._cellCount) {\r\n      throw Error(\r\n        `Requested index ${index} is outside of range 0..${this._cellCount}`,\r\n      );\r\n    }\r\n\r\n    if (index > this._lastMeasuredIndex) {\r\n      let lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\r\n      let offset =\r\n        lastMeasuredCellSizeAndPosition.offset +\r\n        lastMeasuredCellSizeAndPosition.size;\r\n\r\n      for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\r\n        let size = this._cellSizeGetter({index: i});\r\n\r\n        // undefined or NaN probably means a logic error in the size getter.\r\n        // null means we're using CellMeasurer and haven't yet measured a given index.\r\n        if (size === undefined || isNaN(size)) {\r\n          throw Error(`Invalid size returned for cell ${i} of value ${size}`);\r\n        } else if (size === null) {\r\n          this._cellSizeAndPositionData[i] = {\r\n            offset,\r\n            size: 0,\r\n          };\r\n\r\n          this._lastBatchedIndex = index;\r\n        } else {\r\n          this._cellSizeAndPositionData[i] = {\r\n            offset,\r\n            size,\r\n          };\r\n\r\n          offset += size;\r\n\r\n          this._lastMeasuredIndex = index;\r\n        }\r\n      }\r\n    }\r\n\r\n    return this._cellSizeAndPositionData[index];\r\n  }\r\n\r\n  getSizeAndPositionOfLastMeasuredCell(): SizeAndPositionData {\r\n    return this._lastMeasuredIndex >= 0\r\n      ? this._cellSizeAndPositionData[this._lastMeasuredIndex]\r\n      : {\r\n          offset: 0,\r\n          size: 0,\r\n        };\r\n  }\r\n\r\n  /**\r\n   * Total size of all cells being measured.\r\n   * This value will be completely estimated initially.\r\n   * As cells are measured, the estimate will be updated.\r\n   */\r\n  getTotalSize(): number {\r\n    const lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\r\n    const totalSizeOfMeasuredCells =\r\n      lastMeasuredCellSizeAndPosition.offset +\r\n      lastMeasuredCellSizeAndPosition.size;\r\n    const numUnmeasuredCells = this._cellCount - this._lastMeasuredIndex - 1;\r\n    const totalSizeOfUnmeasuredCells =\r\n      numUnmeasuredCells * this._estimatedCellSize;\r\n    return totalSizeOfMeasuredCells + totalSizeOfUnmeasuredCells;\r\n  }\r\n\r\n  /**\r\n   * Determines a new offset that ensures a certain cell is visible, given the current offset.\r\n   * If the cell is already visible then the current offset will be returned.\r\n   * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.\r\n   *\r\n   * @param align Desired alignment within container; one of \"auto\" (default), \"start\", or \"end\"\r\n   * @param containerSize Size (width or height) of the container viewport\r\n   * @param currentOffset Container's current (x or y) offset\r\n   * @param totalSize Total size (width or height) of all cells\r\n   * @return Offset to use to ensure the specified cell is visible\r\n   */\r\n  getUpdatedOffsetForIndex({\r\n    align = 'auto',\r\n    containerSize,\r\n    currentOffset,\r\n    targetIndex,\r\n  }: GetUpdatedOffsetForIndex): number {\r\n    if (containerSize <= 0) {\r\n      return 0;\r\n    }\r\n\r\n    const datum = this.getSizeAndPositionOfCell(targetIndex);\r\n    const maxOffset = datum.offset;\r\n    const minOffset = maxOffset - containerSize + datum.size;\r\n\r\n    let idealOffset;\r\n\r\n    switch (align) {\r\n      case 'start':\r\n        idealOffset = maxOffset;\r\n        break;\r\n      case 'end':\r\n        idealOffset = minOffset;\r\n        break;\r\n      case 'center':\r\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\r\n        break;\r\n      default:\r\n        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\r\n        break;\r\n    }\r\n\r\n    const totalSize = this.getTotalSize();\r\n\r\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\r\n  }\r\n\r\n  getVisibleCellRange(params: GetVisibleCellRangeParams): VisibleCellRange {\r\n    let {containerSize, offset} = params;\r\n\r\n    const totalSize = this.getTotalSize();\r\n\r\n    if (totalSize === 0) {\r\n      return {};\r\n    }\r\n\r\n    const maxOffset = offset + containerSize;\r\n    const start = this._findNearestCell(offset);\r\n\r\n    const datum = this.getSizeAndPositionOfCell(start);\r\n    offset = datum.offset + datum.size;\r\n\r\n    let stop = start;\r\n\r\n    while (offset < maxOffset && stop < this._cellCount - 1) {\r\n      stop++;\r\n\r\n      offset += this.getSizeAndPositionOfCell(stop).size;\r\n    }\r\n\r\n    return {\r\n      start,\r\n      stop,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear all cached values for cells after the specified index.\r\n   * This method should be called for any cell that has changed its size.\r\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.\r\n   */\r\n  resetCell(index: number): void {\r\n    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\r\n  }\r\n\r\n  _binarySearch(high: number, low: number, offset: number): number {\r\n    while (low <= high) {\r\n      const middle = low + Math.floor((high - low) / 2);\r\n      const currentOffset = this.getSizeAndPositionOfCell(middle).offset;\r\n\r\n      if (currentOffset === offset) {\r\n        return middle;\r\n      } else if (currentOffset < offset) {\r\n        low = middle + 1;\r\n      } else if (currentOffset > offset) {\r\n        high = middle - 1;\r\n      }\r\n    }\r\n\r\n    if (low > 0) {\r\n      return low - 1;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  _exponentialSearch(index: number, offset: number): number {\r\n    let interval = 1;\r\n\r\n    while (\r\n      index < this._cellCount &&\r\n      this.getSizeAndPositionOfCell(index).offset < offset\r\n    ) {\r\n      index += interval;\r\n      interval *= 2;\r\n    }\r\n\r\n    return this._binarySearch(\r\n      Math.min(index, this._cellCount - 1),\r\n      Math.floor(index / 2),\r\n      offset,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Searches for the cell (index) nearest the specified offset.\r\n   *\r\n   * If no exact match is found the next lowest cell index will be returned.\r\n   * This allows partially visible cells (with offsets just before/above the fold) to be visible.\r\n   */\r\n  _findNearestCell(offset: number): number {\r\n    if (isNaN(offset)) {\r\n      throw Error(`Invalid offset ${offset} specified`);\r\n    }\r\n\r\n    // Our search algorithms find the nearest match at or below the specified offset.\r\n    // So make sure the offset is at least 0 or no match will be found.\r\n    offset = Math.max(0, offset);\r\n\r\n    const lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\r\n    const lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\r\n\r\n    if (lastMeasuredCellSizeAndPosition.offset >= offset) {\r\n      // If we've already measured cells within this range just use a binary search as it's faster.\r\n      return this._binarySearch(lastMeasuredIndex, 0, offset);\r\n    } else {\r\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\r\n      // The exponential search avoids pre-computing sizes for the full set of cells as a binary search would.\r\n      // The overall complexity for this approach is O(log n).\r\n      return this._exponentialSearch(lastMeasuredIndex, offset);\r\n    }\r\n  }\r\n}\r\n","const DEFAULT_MAX_ELEMENT_SIZE = 1500000;\r\nconst CHROME_MAX_ELEMENT_SIZE = 1.67771e7;\r\n\r\nconst isBrowser = () => typeof window !== 'undefined';\r\n\r\nconst isChrome = () => !!window.chrome;\r\n\r\nexport const getMaxElementSize = () => {\r\n  if (isBrowser()) {\r\n    if (isChrome()) {\r\n      return CHROME_MAX_ELEMENT_SIZE;\r\n    }\r\n  }\r\n  return DEFAULT_MAX_ELEMENT_SIZE;\r\n};\r\n","/** @flow */\r\n\r\nimport type {Alignment, CellSizeGetter, VisibleCellRange} from '../types';\r\n\r\nimport CellSizeAndPositionManager from './CellSizeAndPositionManager';\r\nimport {getMaxElementSize} from './maxElementSize.js';\r\n\r\ntype ContainerSizeAndOffset = {\r\n  containerSize: number,\r\n  offset: number,\r\n};\r\n\r\n/**\r\n * Browsers have scroll offset limitations (eg Chrome stops scrolling at ~33.5M pixels where as Edge tops out at ~1.5M pixels).\r\n * After a certain position, the browser won't allow the user to scroll further (even via JavaScript scroll offset adjustments).\r\n * This util picks a lower ceiling for max size and artificially adjusts positions within to make it transparent for users.\r\n */\r\n\r\ntype Params = {\r\n  maxScrollSize?: number,\r\n  cellCount: number,\r\n  cellSizeGetter: CellSizeGetter,\r\n  estimatedCellSize: number,\r\n};\r\n\r\n/**\r\n * Extends CellSizeAndPositionManager and adds scaling behavior for lists that are too large to fit within a browser's native limits.\r\n */\r\nexport default class ScalingCellSizeAndPositionManager {\r\n  _cellSizeAndPositionManager: CellSizeAndPositionManager;\r\n  _maxScrollSize: number;\r\n\r\n  constructor({maxScrollSize = getMaxElementSize(), ...params}: Params) {\r\n    // Favor composition over inheritance to simplify IE10 support\r\n    this._cellSizeAndPositionManager = new CellSizeAndPositionManager(params);\r\n    this._maxScrollSize = maxScrollSize;\r\n  }\r\n\r\n  areOffsetsAdjusted(): boolean {\r\n    return (\r\n      this._cellSizeAndPositionManager.getTotalSize() > this._maxScrollSize\r\n    );\r\n  }\r\n\r\n  configure(params: {\r\n    cellCount: number,\r\n    estimatedCellSize: number,\r\n    cellSizeGetter: CellSizeGetter,\r\n  }) {\r\n    this._cellSizeAndPositionManager.configure(params);\r\n  }\r\n\r\n  getCellCount(): number {\r\n    return this._cellSizeAndPositionManager.getCellCount();\r\n  }\r\n\r\n  getEstimatedCellSize(): number {\r\n    return this._cellSizeAndPositionManager.getEstimatedCellSize();\r\n  }\r\n\r\n  getLastMeasuredIndex(): number {\r\n    return this._cellSizeAndPositionManager.getLastMeasuredIndex();\r\n  }\r\n\r\n  /**\r\n   * Number of pixels a cell at the given position (offset) should be shifted in order to fit within the scaled container.\r\n   * The offset passed to this function is scaled (safe) as well.\r\n   */\r\n  getOffsetAdjustment({\r\n    containerSize,\r\n    offset, // safe\r\n  }: ContainerSizeAndOffset): number {\r\n    const totalSize = this._cellSizeAndPositionManager.getTotalSize();\r\n    const safeTotalSize = this.getTotalSize();\r\n    const offsetPercentage = this._getOffsetPercentage({\r\n      containerSize,\r\n      offset,\r\n      totalSize: safeTotalSize,\r\n    });\r\n\r\n    return Math.round(offsetPercentage * (safeTotalSize - totalSize));\r\n  }\r\n\r\n  getSizeAndPositionOfCell(index: number) {\r\n    return this._cellSizeAndPositionManager.getSizeAndPositionOfCell(index);\r\n  }\r\n\r\n  getSizeAndPositionOfLastMeasuredCell() {\r\n    return this._cellSizeAndPositionManager.getSizeAndPositionOfLastMeasuredCell();\r\n  }\r\n\r\n  /** See CellSizeAndPositionManager#getTotalSize */\r\n  getTotalSize(): number {\r\n    return Math.min(\r\n      this._maxScrollSize,\r\n      this._cellSizeAndPositionManager.getTotalSize(),\r\n    );\r\n  }\r\n\r\n  /** See CellSizeAndPositionManager#getUpdatedOffsetForIndex */\r\n  getUpdatedOffsetForIndex({\r\n    align = 'auto',\r\n    containerSize,\r\n    currentOffset, // safe\r\n    targetIndex,\r\n  }: {\r\n    align: Alignment,\r\n    containerSize: number,\r\n    currentOffset: number,\r\n    targetIndex: number,\r\n  }) {\r\n    currentOffset = this._safeOffsetToOffset({\r\n      containerSize,\r\n      offset: currentOffset,\r\n    });\r\n\r\n    const offset = this._cellSizeAndPositionManager.getUpdatedOffsetForIndex({\r\n      align,\r\n      containerSize,\r\n      currentOffset,\r\n      targetIndex,\r\n    });\r\n\r\n    return this._offsetToSafeOffset({\r\n      containerSize,\r\n      offset,\r\n    });\r\n  }\r\n\r\n  /** See CellSizeAndPositionManager#getVisibleCellRange */\r\n  getVisibleCellRange({\r\n    containerSize,\r\n    offset, // safe\r\n  }: ContainerSizeAndOffset): VisibleCellRange {\r\n    offset = this._safeOffsetToOffset({\r\n      containerSize,\r\n      offset,\r\n    });\r\n\r\n    return this._cellSizeAndPositionManager.getVisibleCellRange({\r\n      containerSize,\r\n      offset,\r\n    });\r\n  }\r\n\r\n  resetCell(index: number): void {\r\n    this._cellSizeAndPositionManager.resetCell(index);\r\n  }\r\n\r\n  _getOffsetPercentage({\r\n    containerSize,\r\n    offset, // safe\r\n    totalSize,\r\n  }: {\r\n    containerSize: number,\r\n    offset: number,\r\n    totalSize: number,\r\n  }) {\r\n    return totalSize <= containerSize\r\n      ? 0\r\n      : offset / (totalSize - containerSize);\r\n  }\r\n\r\n  _offsetToSafeOffset({\r\n    containerSize,\r\n    offset, // unsafe\r\n  }: ContainerSizeAndOffset): number {\r\n    const totalSize = this._cellSizeAndPositionManager.getTotalSize();\r\n    const safeTotalSize = this.getTotalSize();\r\n\r\n    if (totalSize === safeTotalSize) {\r\n      return offset;\r\n    } else {\r\n      const offsetPercentage = this._getOffsetPercentage({\r\n        containerSize,\r\n        offset,\r\n        totalSize,\r\n      });\r\n\r\n      return Math.round(offsetPercentage * (safeTotalSize - containerSize));\r\n    }\r\n  }\r\n\r\n  _safeOffsetToOffset({\r\n    containerSize,\r\n    offset, // safe\r\n  }: ContainerSizeAndOffset): number {\r\n    const totalSize = this._cellSizeAndPositionManager.getTotalSize();\r\n    const safeTotalSize = this.getTotalSize();\r\n\r\n    if (totalSize === safeTotalSize) {\r\n      return offset;\r\n    } else {\r\n      const offsetPercentage = this._getOffsetPercentage({\r\n        containerSize,\r\n        offset,\r\n        totalSize: safeTotalSize,\r\n      });\r\n\r\n      return Math.round(offsetPercentage * (totalSize - containerSize));\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Helper utility that updates the specified callback whenever any of the specified indices have changed.\r\n */\r\nexport default function createCallbackMemoizer(requireAllKeys = true) {\r\n  let cachedIndices = {};\r\n\r\n  return ({callback, indices}) => {\r\n    const keys = Object.keys(indices);\r\n    const allInitialized =\r\n      !requireAllKeys ||\r\n      keys.every(key => {\r\n        const value = indices[key];\r\n        return Array.isArray(value) ? value.length > 0 : value >= 0;\r\n      });\r\n    const indexChanged =\r\n      keys.length !== Object.keys(cachedIndices).length ||\r\n      keys.some(key => {\r\n        const cachedValue = cachedIndices[key];\r\n        const value = indices[key];\r\n\r\n        return Array.isArray(value)\r\n          ? cachedValue.join(',') !== value.join(',')\r\n          : cachedValue !== value;\r\n      });\r\n\r\n    cachedIndices = indices;\r\n\r\n    if (allInitialized && indexChanged) {\r\n      callback(indices);\r\n    }\r\n  };\r\n}\r\n","// @flow\r\n\r\nimport type {Alignment, CellSize} from '../types';\r\n\r\nimport ScalingCellSizeAndPositionManager from './ScalingCellSizeAndPositionManager.js';\r\n\r\n/**\r\n * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.\r\n * This function also ensures that the scroll ofset isn't past the last column/row of cells.\r\n */\r\n\r\ntype Params = {\r\n  // Width or height of cells for the current axis\r\n  cellSize?: CellSize,\r\n\r\n  // Manages size and position metadata of cells\r\n  cellSizeAndPositionManager: ScalingCellSizeAndPositionManager,\r\n\r\n  // Previous number of rows or columns\r\n  previousCellsCount: number,\r\n\r\n  // Previous width or height of cells\r\n  previousCellSize: CellSize,\r\n\r\n  previousScrollToAlignment: Alignment,\r\n\r\n  // Previous scroll-to-index\r\n  previousScrollToIndex: number,\r\n\r\n  // Previous width or height of the virtualized container\r\n  previousSize: number,\r\n\r\n  // Current scrollLeft or scrollTop\r\n  scrollOffset: number,\r\n\r\n  scrollToAlignment: Alignment,\r\n\r\n  // Scroll-to-index\r\n  scrollToIndex: number,\r\n\r\n  // Width or height of the virtualized container\r\n  size: number,\r\n\r\n  sizeJustIncreasedFromZero: boolean,\r\n\r\n  // Callback to invoke with an scroll-to-index value\r\n  updateScrollIndexCallback: (index: number) => void,\r\n};\r\n\r\nexport default function updateScrollIndexHelper({\r\n  cellSize,\r\n  cellSizeAndPositionManager,\r\n  previousCellsCount,\r\n  previousCellSize,\r\n  previousScrollToAlignment,\r\n  previousScrollToIndex,\r\n  previousSize,\r\n  scrollOffset,\r\n  scrollToAlignment,\r\n  scrollToIndex,\r\n  size,\r\n  sizeJustIncreasedFromZero,\r\n  updateScrollIndexCallback,\r\n}: Params) {\r\n  const cellCount = cellSizeAndPositionManager.getCellCount();\r\n  const hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;\r\n  const sizeHasChanged =\r\n    size !== previousSize ||\r\n    sizeJustIncreasedFromZero ||\r\n    !previousCellSize ||\r\n    (typeof cellSize === 'number' && cellSize !== previousCellSize);\r\n\r\n  // If we have a new scroll target OR if height/row-height has changed,\r\n  // We should ensure that the scroll target is visible.\r\n  if (\r\n    hasScrollToIndex &&\r\n    (sizeHasChanged ||\r\n      scrollToAlignment !== previousScrollToAlignment ||\r\n      scrollToIndex !== previousScrollToIndex)\r\n  ) {\r\n    updateScrollIndexCallback(scrollToIndex);\r\n\r\n    // If we don't have a selected item but list size or number of children have decreased,\r\n    // Make sure we aren't scrolled too far past the current content.\r\n  } else if (\r\n    !hasScrollToIndex &&\r\n    cellCount > 0 &&\r\n    (size < previousSize || cellCount < previousCellsCount)\r\n  ) {\r\n    // We need to ensure that the current scroll offset is still within the collection's range.\r\n    // To do this, we don't need to measure everything; CellMeasurer would perform poorly.\r\n    // Just check to make sure we're still okay.\r\n    // Only adjust the scroll position if we've scrolled below the last set of rows.\r\n    if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {\r\n      updateScrollIndexCallback(cellCount - 1);\r\n    }\r\n  }\r\n}\r\n","\r\n// Properly handle server-side rendering.\r\nlet win;\r\nif (typeof window !== 'undefined') {\r\n  win = window;\r\n} else if (typeof window.self !== 'undefined') {\r\n  win = window.self;\r\n} else {\r\n  win = {};\r\n}\r\n\r\n// requestAnimationFrame() shim by Paul Irish\r\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\nconst request =\r\n  win.requestAnimationFrame ||\r\n  win.webkitRequestAnimationFrame ||\r\n  win.mozRequestAnimationFrame ||\r\n  win.oRequestAnimationFrame ||\r\n  win.msRequestAnimationFrame ||\r\n  function(callback) {\r\n    return (win).setTimeout(callback, 1000 / 60);\r\n  };\r\n\r\nconst cancel =\r\n  win.cancelAnimationFrame ||\r\n  win.webkitCancelAnimationFrame ||\r\n  win.mozCancelAnimationFrame ||\r\n  win.oCancelAnimationFrame ||\r\n  win.msCancelAnimationFrame ||\r\n  function(id) {\r\n    (win).clearTimeout(id);\r\n  };\r\n\r\nexport const raf = (request);\r\nexport const caf = (cancel);\r\n","/** @flow */\r\n\r\nimport {caf, raf} from './animationFrame';\r\n\r\nexport type AnimationTimeoutId = {\r\n  id: number,\r\n};\r\n\r\nexport const cancelAnimationTimeout = (frame: AnimationTimeoutId) =>\r\n  caf(frame.id);\r\n\r\n/**\r\n * Recursively calls requestAnimationFrame until a specified delay has been met or exceeded.\r\n * When the delay time has been reached the function you're timing out will be called.\r\n *\r\n * Credit: Joe Lambert (https://gist.github.com/joelambert/1002116#file-requesttimeout-js)\r\n */\r\nexport const requestAnimationTimeout = (\r\n  callback: Function,\r\n  delay: number,\r\n): AnimationTimeoutId => {\r\n  let start;\r\n  // wait for end of processing current event handler, because event handler may be long\r\n  Promise.resolve().then(() => {\r\n    start = Date.now();\r\n  });\r\n\r\n  const timeout = () => {\r\n    if (Date.now() - start >= delay) {\r\n      callback.call();\r\n    } else {\r\n      frame.id = raf(timeout);\r\n    }\r\n  };\r\n\r\n  const frame: AnimationTimeoutId = {\r\n    id: raf(timeout),\r\n  };\r\n\r\n  return frame;\r\n};\r\n","import * as React from \"react\";\r\nimport clsx from \"clsx\";\r\nimport calculateSizeAndPositionDataAndUpdateScrollOffset from \"./utils/calculateSizeAndPositionDataAndUpdateScrollOffset\";\r\nimport ScalingCellSizeAndPositionManager from \"./utils/ScalingCellSizeAndPositionManager\";\r\nimport createCallbackMemoizer from \"../utils/createCallbackMemoizer\";\r\nimport defaultOverscanIndicesGetter, {\r\n  SCROLL_DIRECTION_BACKWARD,\r\n  SCROLL_DIRECTION_FORWARD\r\n} from \"./defaultOverscanIndicesGetter\";\r\nimport updateScrollIndexHelper from \"./utils/updateScrollIndexHelper\";\r\nimport defaultCellRangeRenderer from \"./defaultCellRangeRenderer\";\r\nimport scrollbarSize from \"dom-helpers/scrollbarSize\";\r\nimport { polyfill } from \"react-lifecycles-compat\";\r\nimport {\r\n  requestAnimationTimeout,\r\n  cancelAnimationTimeout\r\n} from \"../utils/requestAnimationTimeout\";\r\n\r\n/**\r\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\r\n * This improves performance and makes scrolling smoother.\r\n */\r\nexport const DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;\r\n\r\n/**\r\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\r\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\r\n */\r\nconst SCROLL_POSITION_CHANGE_REASONS = {\r\n  OBSERVED: \"observed\",\r\n  REQUESTED: \"requested\"\r\n};\r\n\r\nconst renderNull = () => null;\r\n\r\n/**\r\n * Renders tabular data with virtualization along the vertical and horizontal axes.\r\n * Row heights and column widths must be known ahead of time and specified as properties.\r\n */\r\nclass Grid extends React.PureComponent {\r\n  static defaultProps = {\r\n    \"aria-label\": \"grid\",\r\n    \"aria-readonly\": true,\r\n    autoContainerWidth: false,\r\n    autoHeight: false,\r\n    autoWidth: false,\r\n    cellRangeRenderer: defaultCellRangeRenderer,\r\n    containerRole: \"rowgroup\",\r\n    containerStyle: {},\r\n    estimatedColumnSize: 100,\r\n    estimatedRowSize: 30,\r\n    getScrollbarSize: scrollbarSize,\r\n    noContentRenderer: renderNull,\r\n    onScroll: () => {},\r\n    onScrollbarPresenceChange: () => {},\r\n    onSectionRendered: () => {},\r\n    overscanColumnCount: 0,\r\n    overscanIndicesGetter: defaultOverscanIndicesGetter,\r\n    overscanRowCount: 10,\r\n    role: \"grid\",\r\n    scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,\r\n    scrollToAlignment: \"auto\",\r\n    scrollToColumn: -1,\r\n    scrollToRow: -1,\r\n    style: {},\r\n    tabIndex: 0,\r\n    isScrollingOptOut: false\r\n  };\r\n\r\n  // Invokes onSectionRendered callback only when start/stop row or column indices change\r\n  _onGridRenderedMemoizer = createCallbackMemoizer();\r\n  _onScrollMemoizer = createCallbackMemoizer(false);\r\n\r\n  _deferredInvalidateColumnIndex = null;\r\n  _deferredInvalidateRowIndex = null;\r\n  _recomputeScrollLeftFlag = false;\r\n  _recomputeScrollTopFlag = false;\r\n\r\n  _horizontalScrollBarSize = 0;\r\n  _verticalScrollBarSize = 0;\r\n  _scrollbarPresenceChanged = false;\r\n  _scrollingContainer;\r\n\r\n  _childrenToDisplay;\r\n\r\n  _columnStartIndex;\r\n  _columnStopIndex;\r\n  _rowStartIndex;\r\n  _rowStopIndex;\r\n  _renderedColumnStartIndex = 0;\r\n  _renderedColumnStopIndex = 0;\r\n  _renderedRowStartIndex = 0;\r\n  _renderedRowStopIndex = 0;\r\n\r\n  _initialScrollTop;\r\n  _initialScrollLeft;\r\n\r\n  _disablePointerEventsTimeoutId;\r\n\r\n  _styleCache = {};\r\n  _cellCache = {};\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    const columnSizeAndPositionManager = new ScalingCellSizeAndPositionManager({\r\n      cellCount: props.columnCount,\r\n      cellSizeGetter: params => Grid._wrapSizeGetter(props.columnWidth)(params),\r\n      estimatedCellSize: Grid._getEstimatedColumnSize(props)\r\n    });\r\n    const rowSizeAndPositionManager = new ScalingCellSizeAndPositionManager({\r\n      cellCount: props.rowCount,\r\n      cellSizeGetter: params => Grid._wrapSizeGetter(props.rowHeight)(params),\r\n      estimatedCellSize: Grid._getEstimatedRowSize(props)\r\n    });\r\n\r\n    this.state = {\r\n      instanceProps: {\r\n        columnSizeAndPositionManager,\r\n        rowSizeAndPositionManager,\r\n\r\n        prevColumnWidth: props.columnWidth,\r\n        prevRowHeight: props.rowHeight,\r\n        prevColumnCount: props.columnCount,\r\n        prevRowCount: props.rowCount,\r\n        prevIsScrolling: props.isScrolling === true,\r\n        prevScrollToColumn: props.scrollToColumn,\r\n        prevScrollToRow: props.scrollToRow,\r\n\r\n        scrollbarSize: 0,\r\n        scrollbarSizeMeasured: false\r\n      },\r\n      isScrolling: false,\r\n      scrollDirectionHorizontal: SCROLL_DIRECTION_FORWARD,\r\n      scrollDirectionVertical: SCROLL_DIRECTION_FORWARD,\r\n      scrollLeft: 0,\r\n      scrollTop: 0,\r\n      scrollPositionChangeReason: null,\r\n\r\n      needToResetStyleCache: false\r\n    };\r\n\r\n    if (props.scrollToRow > 0) {\r\n      this._initialScrollTop = this._getCalculatedScrollTop(props, this.state);\r\n    }\r\n    if (props.scrollToColumn > 0) {\r\n      this._initialScrollLeft = this._getCalculatedScrollLeft(\r\n        props,\r\n        this.state\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets offsets for a given cell and alignment.\r\n   */\r\n  getOffsetForCell({\r\n    alignment = this.props.scrollToAlignment,\r\n    columnIndex = this.props.scrollToColumn,\r\n    rowIndex = this.props.scrollToRow\r\n  }) {\r\n    const offsetProps = {\r\n      ...this.props,\r\n      scrollToAlignment: alignment,\r\n      scrollToColumn: columnIndex,\r\n      scrollToRow: rowIndex\r\n    };\r\n\r\n    return {\r\n      scrollLeft: this._getCalculatedScrollLeft(offsetProps),\r\n      scrollTop: this._getCalculatedScrollTop(offsetProps)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets estimated total rows' height.\r\n   */\r\n  getTotalRowsHeight() {\r\n    return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();\r\n  }\r\n\r\n  /**\r\n   * Gets estimated total columns' width.\r\n   */\r\n  getTotalColumnsWidth() {\r\n    return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();\r\n  }\r\n\r\n  /**\r\n   * This method handles a scroll event originating from an external scroll control.\r\n   * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.\r\n   */\r\n  handleScrollEvent({\r\n    scrollLeft: scrollLeftParam = 0,\r\n    scrollTop: scrollTopParam = 0\r\n  }) {\r\n    // On iOS, we can arrive at negative offsets by swiping past the start.\r\n    // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.\r\n    if (scrollTopParam < 0) {\r\n      return;\r\n    }\r\n\r\n    // Prevent pointer events from interrupting a smooth scroll\r\n    this._debounceScrollEnded();\r\n\r\n    const { autoHeight, autoWidth, height, width } = this.props;\r\n    const { instanceProps } = this.state;\r\n\r\n    // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\r\n    // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\r\n    // This causes a series of rapid renders that is slow for long lists.\r\n    // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.\r\n    const scrollbarSize = instanceProps.scrollbarSize;\r\n    const totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\r\n    const totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\r\n    const scrollLeft = Math.min(\r\n      Math.max(0, totalColumnsWidth - width + scrollbarSize),\r\n      scrollLeftParam\r\n    );\r\n    const scrollTop = Math.min(\r\n      Math.max(0, totalRowsHeight - height + scrollbarSize),\r\n      scrollTopParam\r\n    );\r\n\r\n    // Certain devices (like Apple touchpad) rapid-fire duplicate events.\r\n    // Don't force a re-render if this is the case.\r\n    // The mouse may move faster then the animation frame does.\r\n    // Use requestAnimationFrame to avoid over-updating.\r\n    if (\r\n      this.state.scrollLeft !== scrollLeft ||\r\n      this.state.scrollTop !== scrollTop\r\n    ) {\r\n      // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.\r\n      // Don't change direction for an axis unless scroll offset has changed.\r\n      const scrollDirectionHorizontal =\r\n        scrollLeft !== this.state.scrollLeft\r\n          ? scrollLeft > this.state.scrollLeft\r\n            ? SCROLL_DIRECTION_FORWARD\r\n            : SCROLL_DIRECTION_BACKWARD\r\n          : this.state.scrollDirectionHorizontal;\r\n      const scrollDirectionVertical =\r\n        scrollTop !== this.state.scrollTop\r\n          ? scrollTop > this.state.scrollTop\r\n            ? SCROLL_DIRECTION_FORWARD\r\n            : SCROLL_DIRECTION_BACKWARD\r\n          : this.state.scrollDirectionVertical;\r\n\r\n      const newState = {\r\n        isScrolling: true,\r\n        scrollDirectionHorizontal,\r\n        scrollDirectionVertical,\r\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED\r\n      };\r\n\r\n      if (!autoHeight) {\r\n        newState.scrollTop = scrollTop;\r\n      }\r\n\r\n      if (!autoWidth) {\r\n        newState.scrollLeft = scrollLeft;\r\n      }\r\n\r\n      newState.needToResetStyleCache = false;\r\n      this.setState(newState);\r\n    }\r\n\r\n    this._invokeOnScrollMemoizer({\r\n      scrollLeft,\r\n      scrollTop,\r\n      totalColumnsWidth,\r\n      totalRowsHeight\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Invalidate Grid size and recompute visible cells.\r\n   * This is a deferred wrapper for recomputeGridSize().\r\n   * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.\r\n   * This method is intended for advanced use-cases like CellMeasurer.\r\n   */\r\n  // @TODO (bvaughn) Add automated test coverage for this.\r\n  invalidateCellSizeAfterRender({ columnIndex, rowIndex }) {\r\n    this._deferredInvalidateColumnIndex =\r\n      typeof this._deferredInvalidateColumnIndex === \"number\"\r\n        ? Math.min(this._deferredInvalidateColumnIndex, columnIndex)\r\n        : columnIndex;\r\n    this._deferredInvalidateRowIndex =\r\n      typeof this._deferredInvalidateRowIndex === \"number\"\r\n        ? Math.min(this._deferredInvalidateRowIndex, rowIndex)\r\n        : rowIndex;\r\n  }\r\n\r\n  /**\r\n   * Pre-measure all columns and rows in a Grid.\r\n   * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.\r\n   * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).\r\n   */\r\n  measureAllCells() {\r\n    const { columnCount, rowCount } = this.props;\r\n    const { instanceProps } = this.state;\r\n    instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(\r\n      columnCount - 1\r\n    );\r\n    instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(\r\n      rowCount - 1\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Forced recompute of row heights and column widths.\r\n   * This function should be called if dynamic column or row sizes have changed but nothing else has.\r\n   * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.\r\n   */\r\n  recomputeGridSize({ columnIndex = 0, rowIndex = 0 }) {\r\n    const { scrollToColumn, scrollToRow } = this.props;\r\n    const { instanceProps } = this.state;\r\n\r\n    instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);\r\n    instanceProps.rowSizeAndPositionManager.resetCell(rowIndex);\r\n\r\n    // Cell sizes may be determined by a function property.\r\n    // In this case the cDU handler can't know if they changed.\r\n    // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.\r\n    this._recomputeScrollLeftFlag =\r\n      scrollToColumn >= 0 &&\r\n      (this.state.scrollDirectionHorizontal === SCROLL_DIRECTION_FORWARD\r\n        ? columnIndex <= scrollToColumn\r\n        : columnIndex >= scrollToColumn);\r\n    this._recomputeScrollTopFlag =\r\n      scrollToRow >= 0 &&\r\n      (this.state.scrollDirectionVertical === SCROLL_DIRECTION_FORWARD\r\n        ? rowIndex <= scrollToRow\r\n        : rowIndex >= scrollToRow);\r\n\r\n    // Clear cell cache in case we are scrolling;\r\n    // Invalid row heights likely mean invalid cached content as well.\r\n    this._styleCache = {};\r\n    this._cellCache = {};\r\n\r\n    this.forceUpdate();\r\n  }\r\n\r\n  /**\r\n   * Ensure column and row are visible.\r\n   */\r\n  scrollToCell({ columnIndex, rowIndex }) {\r\n    const { columnCount } = this.props;\r\n\r\n    const props = this.props;\r\n\r\n    // Don't adjust scroll offset for single-column grids (eg List, Table).\r\n    // This can cause a funky scroll offset because of the vertical scrollbar width.\r\n    if (columnCount > 1 && columnIndex !== undefined) {\r\n      this._updateScrollLeftForScrollToColumn({\r\n        ...props,\r\n        scrollToColumn: columnIndex\r\n      });\r\n    }\r\n\r\n    if (rowIndex !== undefined) {\r\n      this._updateScrollTopForScrollToRow({\r\n        ...props,\r\n        scrollToRow: rowIndex\r\n      });\r\n    }\r\n  }\r\n\r\n  componentDidMount() {\r\n    const {\r\n      getScrollbarSize,\r\n      height,\r\n      scrollLeft,\r\n      scrollToColumn,\r\n      scrollTop,\r\n      scrollToRow,\r\n      width\r\n    } = this.props;\r\n\r\n    const { instanceProps } = this.state;\r\n\r\n    // Reset initial offsets to be ignored in browser\r\n    this._initialScrollTop = 0;\r\n    this._initialScrollLeft = 0;\r\n\r\n    // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\r\n    // We must do this at the start of the method as we may calculate and update scroll position below.\r\n    this._handleInvalidatedGridSize();\r\n\r\n    // If this component was first rendered server-side, scrollbar size will be undefined.\r\n    // In that event we need to remeasure.\r\n    if (!instanceProps.scrollbarSizeMeasured) {\r\n      this.setState(prevState => {\r\n        const stateUpdate = { ...prevState, needToResetStyleCache: false };\r\n        stateUpdate.instanceProps.scrollbarSize = getScrollbarSize();\r\n        stateUpdate.instanceProps.scrollbarSizeMeasured = true;\r\n        return stateUpdate;\r\n      });\r\n    }\r\n\r\n    if (\r\n      (typeof scrollLeft === \"number\" && scrollLeft >= 0) ||\r\n      (typeof scrollTop === \"number\" && scrollTop >= 0)\r\n    ) {\r\n      const stateUpdate = Grid._getScrollToPositionStateUpdate({\r\n        prevState: this.state,\r\n        scrollLeft,\r\n        scrollTop\r\n      });\r\n      if (stateUpdate) {\r\n        stateUpdate.needToResetStyleCache = false;\r\n        this.setState(stateUpdate);\r\n      }\r\n    }\r\n\r\n    // refs don't work in `react-test-renderer`\r\n    if (this._scrollingContainer) {\r\n      // setting the ref's scrollLeft and scrollTop.\r\n      // Somehow in MultiGrid the main grid doesn't trigger a update on mount.\r\n      if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {\r\n        this._scrollingContainer.scrollLeft = this.state.scrollLeft;\r\n      }\r\n      if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {\r\n        this._scrollingContainer.scrollTop = this.state.scrollTop;\r\n      }\r\n    }\r\n\r\n    // Don't update scroll offset if the size is 0; we don't render any cells in this case.\r\n    // Setting a state may cause us to later thing we've updated the offce when we haven't.\r\n    const sizeIsBiggerThanZero = height > 0 && width > 0;\r\n    if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {\r\n      this._updateScrollLeftForScrollToColumn();\r\n    }\r\n    if (scrollToRow >= 0 && sizeIsBiggerThanZero) {\r\n      this._updateScrollTopForScrollToRow();\r\n    }\r\n\r\n    // Update onRowsRendered callback\r\n    this._invokeOnGridRenderedHelper();\r\n\r\n    // Initialize onScroll callback\r\n    this._invokeOnScrollMemoizer({\r\n      scrollLeft: scrollLeft || 0,\r\n      scrollTop: scrollTop || 0,\r\n      totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),\r\n      totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()\r\n    });\r\n\r\n    this._maybeCallOnScrollbarPresenceChange();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * This method updates scrollLeft/scrollTop in state for the following conditions:\r\n   * 1) New scroll-to-cell props have been set\r\n   */\r\n  componentDidUpdate(prevProps, prevState) {\r\n    const {\r\n      autoHeight,\r\n      autoWidth,\r\n      columnCount,\r\n      height,\r\n      rowCount,\r\n      scrollToAlignment,\r\n      scrollToColumn,\r\n      scrollToRow,\r\n      width\r\n    } = this.props;\r\n    const {\r\n      scrollLeft,\r\n      scrollPositionChangeReason,\r\n      scrollTop,\r\n      instanceProps\r\n    } = this.state;\r\n    // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\r\n    // We must do this at the start of the method as we may calculate and update scroll position below.\r\n    this._handleInvalidatedGridSize();\r\n\r\n    // Handle edge case where column or row count has only just increased over 0.\r\n    // In this case we may have to restore a previously-specified scroll offset.\r\n    // For more info see bvaughn/react-virtualized/issues/218\r\n    const columnOrRowCountJustIncreasedFromZero =\r\n      (columnCount > 0 && prevProps.columnCount === 0) ||\r\n      (rowCount > 0 && prevProps.rowCount === 0);\r\n\r\n    // Make sure requested changes to :scrollLeft or :scrollTop get applied.\r\n    // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\r\n    // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\r\n    // So we only set these when we require an adjustment of the scroll position.\r\n    // See issue #2 for more information.\r\n    if (\r\n      scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED\r\n    ) {\r\n      // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).\r\n      // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.\r\n      if (\r\n        !autoWidth &&\r\n        scrollLeft >= 0 &&\r\n        (scrollLeft !== this._scrollingContainer.scrollLeft ||\r\n          columnOrRowCountJustIncreasedFromZero)\r\n      ) {\r\n        this._scrollingContainer.scrollLeft = scrollLeft;\r\n      }\r\n      if (\r\n        !autoHeight &&\r\n        scrollTop >= 0 &&\r\n        (scrollTop !== this._scrollingContainer.scrollTop ||\r\n          columnOrRowCountJustIncreasedFromZero)\r\n      ) {\r\n        this._scrollingContainer.scrollTop = scrollTop;\r\n      }\r\n    }\r\n\r\n    // Special case where the previous size was 0:\r\n    // In this case we don't show any windowed cells at all.\r\n    // So we should always recalculate offset afterwards.\r\n    const sizeJustIncreasedFromZero =\r\n      (prevProps.width === 0 || prevProps.height === 0) &&\r\n      height > 0 &&\r\n      width > 0;\r\n\r\n    // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it\r\n    // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?\r\n    if (this._recomputeScrollLeftFlag) {\r\n      this._recomputeScrollLeftFlag = false;\r\n      this._updateScrollLeftForScrollToColumn(this.props);\r\n    } else {\r\n      updateScrollIndexHelper({\r\n        cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\r\n        previousCellsCount: prevProps.columnCount,\r\n        previousCellSize: prevProps.columnWidth,\r\n        previousScrollToAlignment: prevProps.scrollToAlignment,\r\n        previousScrollToIndex: prevProps.scrollToColumn,\r\n        previousSize: prevProps.width,\r\n        scrollOffset: scrollLeft,\r\n        scrollToAlignment,\r\n        scrollToIndex: scrollToColumn,\r\n        size: width,\r\n        sizeJustIncreasedFromZero,\r\n        updateScrollIndexCallback: () =>\r\n          this._updateScrollLeftForScrollToColumn(this.props)\r\n      });\r\n    }\r\n\r\n    if (this._recomputeScrollTopFlag) {\r\n      this._recomputeScrollTopFlag = false;\r\n      this._updateScrollTopForScrollToRow(this.props);\r\n    } else {\r\n      updateScrollIndexHelper({\r\n        cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\r\n        previousCellsCount: prevProps.rowCount,\r\n        previousCellSize: prevProps.rowHeight,\r\n        previousScrollToAlignment: prevProps.scrollToAlignment,\r\n        previousScrollToIndex: prevProps.scrollToRow,\r\n        previousSize: prevProps.height,\r\n        scrollOffset: scrollTop,\r\n        scrollToAlignment,\r\n        scrollToIndex: scrollToRow,\r\n        size: height,\r\n        sizeJustIncreasedFromZero,\r\n        updateScrollIndexCallback: () =>\r\n          this._updateScrollTopForScrollToRow(this.props)\r\n      });\r\n    }\r\n\r\n    // Update onRowsRendered callback if start/stop indices have changed\r\n    this._invokeOnGridRenderedHelper();\r\n\r\n    // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners\r\n    if (\r\n      scrollLeft !== prevState.scrollLeft ||\r\n      scrollTop !== prevState.scrollTop\r\n    ) {\r\n      const totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\r\n      const totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\r\n\r\n      this._invokeOnScrollMemoizer({\r\n        scrollLeft,\r\n        scrollTop,\r\n        totalColumnsWidth,\r\n        totalRowsHeight\r\n      });\r\n    }\r\n\r\n    this._maybeCallOnScrollbarPresenceChange();\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    if (this._disablePointerEventsTimeoutId) {\r\n      cancelAnimationTimeout(this._disablePointerEventsTimeoutId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method updates scrollLeft/scrollTop in state for the following conditions:\r\n   * 1) Empty content (0 rows or columns)\r\n   * 2) New scroll props overriding the current state\r\n   * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\r\n   */\r\n  static getDerivedStateFromProps(nextProps, prevState) {\r\n    const newState = {};\r\n\r\n    if (\r\n      (nextProps.columnCount === 0 && prevState.scrollLeft !== 0) ||\r\n      (nextProps.rowCount === 0 && prevState.scrollTop !== 0)\r\n    ) {\r\n      newState.scrollLeft = 0;\r\n      newState.scrollTop = 0;\r\n\r\n      // only use scroll{Left,Top} from props if scrollTo{Column,Row} isn't specified\r\n      // scrollTo{Column,Row} should override scroll{Left,Top}\r\n    } else if (\r\n      (nextProps.scrollLeft !== prevState.scrollLeft &&\r\n        nextProps.scrollToColumn < 0) ||\r\n      (nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0)\r\n    ) {\r\n      Object.assign(\r\n        newState,\r\n        Grid._getScrollToPositionStateUpdate({\r\n          prevState,\r\n          scrollLeft: nextProps.scrollLeft,\r\n          scrollTop: nextProps.scrollTop\r\n        })\r\n      );\r\n    }\r\n\r\n    let { instanceProps } = prevState;\r\n\r\n    // Initially we should not clearStyleCache\r\n    newState.needToResetStyleCache = false;\r\n    if (\r\n      nextProps.columnWidth !== instanceProps.prevColumnWidth ||\r\n      nextProps.rowHeight !== instanceProps.prevRowHeight\r\n    ) {\r\n      // Reset cache. set it to {} in render\r\n      newState.needToResetStyleCache = true;\r\n    }\r\n\r\n    instanceProps.columnSizeAndPositionManager.configure({\r\n      cellCount: nextProps.columnCount,\r\n      estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),\r\n      cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)\r\n    });\r\n\r\n    instanceProps.rowSizeAndPositionManager.configure({\r\n      cellCount: nextProps.rowCount,\r\n      estimatedCellSize: Grid._getEstimatedRowSize(nextProps),\r\n      cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)\r\n    });\r\n\r\n    if (\r\n      instanceProps.prevColumnCount === 0 ||\r\n      instanceProps.prevRowCount === 0\r\n    ) {\r\n      instanceProps.prevColumnCount = 0;\r\n      instanceProps.prevRowCount = 0;\r\n    }\r\n\r\n    // If scrolling is controlled outside this component, clear cache when scrolling stops\r\n    if (\r\n      nextProps.autoHeight &&\r\n      nextProps.isScrolling === false &&\r\n      instanceProps.prevIsScrolling === true\r\n    ) {\r\n      Object.assign(newState, {\r\n        isScrolling: false\r\n      });\r\n    }\r\n\r\n    let maybeStateA;\r\n    let maybeStateB;\r\n\r\n    calculateSizeAndPositionDataAndUpdateScrollOffset({\r\n      cellCount: instanceProps.prevColumnCount,\r\n      cellSize:\r\n        typeof instanceProps.prevColumnWidth === \"number\"\r\n          ? instanceProps.prevColumnWidth\r\n          : null,\r\n      computeMetadataCallback: () =>\r\n        instanceProps.columnSizeAndPositionManager.resetCell(0),\r\n      computeMetadataCallbackProps: nextProps,\r\n      nextCellsCount: nextProps.columnCount,\r\n      nextCellSize:\r\n        typeof nextProps.columnWidth === \"number\"\r\n          ? nextProps.columnWidth\r\n          : null,\r\n      nextScrollToIndex: nextProps.scrollToColumn,\r\n      scrollToIndex: instanceProps.prevScrollToColumn,\r\n      updateScrollOffsetForScrollToIndex: () => {\r\n        maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(\r\n          nextProps,\r\n          prevState\r\n        );\r\n      }\r\n    });\r\n    calculateSizeAndPositionDataAndUpdateScrollOffset({\r\n      cellCount: instanceProps.prevRowCount,\r\n      cellSize:\r\n        typeof instanceProps.prevRowHeight === \"number\"\r\n          ? instanceProps.prevRowHeight\r\n          : null,\r\n      computeMetadataCallback: () =>\r\n        instanceProps.rowSizeAndPositionManager.resetCell(0),\r\n      computeMetadataCallbackProps: nextProps,\r\n      nextCellsCount: nextProps.rowCount,\r\n      nextCellSize:\r\n        typeof nextProps.rowHeight === \"number\" ? nextProps.rowHeight : null,\r\n      nextScrollToIndex: nextProps.scrollToRow,\r\n      scrollToIndex: instanceProps.prevScrollToRow,\r\n      updateScrollOffsetForScrollToIndex: () => {\r\n        maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(\r\n          nextProps,\r\n          prevState\r\n        );\r\n      }\r\n    });\r\n\r\n    instanceProps.prevColumnCount = nextProps.columnCount;\r\n    instanceProps.prevColumnWidth = nextProps.columnWidth;\r\n    instanceProps.prevIsScrolling = nextProps.isScrolling === true;\r\n    instanceProps.prevRowCount = nextProps.rowCount;\r\n    instanceProps.prevRowHeight = nextProps.rowHeight;\r\n    instanceProps.prevScrollToColumn = nextProps.scrollToColumn;\r\n    instanceProps.prevScrollToRow = nextProps.scrollToRow;\r\n\r\n    // getting scrollBarSize (moved from componentWillMount)\r\n    instanceProps.scrollbarSize = nextProps.getScrollbarSize();\r\n    if (instanceProps.scrollbarSize === undefined) {\r\n      instanceProps.scrollbarSizeMeasured = false;\r\n      instanceProps.scrollbarSize = 0;\r\n    } else {\r\n      instanceProps.scrollbarSizeMeasured = true;\r\n    }\r\n\r\n    newState.instanceProps = instanceProps;\r\n\r\n    return { ...newState, ...maybeStateA, ...maybeStateB };\r\n  }\r\n\r\n  render() {\r\n    const {\r\n      autoContainerWidth,\r\n      autoHeight,\r\n      autoWidth,\r\n      className,\r\n      containerProps,\r\n      containerRole,\r\n      containerStyle,\r\n      height,\r\n      id,\r\n      noContentRenderer,\r\n      role,\r\n      style,\r\n      tabIndex,\r\n      width\r\n    } = this.props;\r\n    const { instanceProps, needToResetStyleCache } = this.state;\r\n\r\n    const isScrolling = this._isScrolling();\r\n\r\n    const gridStyle = {\r\n      boxSizing: \"border-box\",\r\n      direction: \"ltr\",\r\n      height: autoHeight ? \"auto\" : height,\r\n      position: \"relative\",\r\n      width: autoWidth ? \"auto\" : width,\r\n      WebkitOverflowScrolling: \"touch\",\r\n      willChange: \"transform\"\r\n    };\r\n\r\n    if (needToResetStyleCache) {\r\n      this._styleCache = {};\r\n    }\r\n\r\n    // calculate _styleCache here\r\n    // if state.isScrolling (not from _isScrolling) then reset\r\n    if (!this.state.isScrolling) {\r\n      this._resetStyleCache();\r\n    }\r\n\r\n    // calculate children to render here\r\n    this._calculateChildrenToRender(this.props, this.state);\r\n\r\n    const totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\r\n    const totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\r\n\r\n    // Force browser to hide scrollbars when we know they aren't necessary.\r\n    // Otherwise once scrollbars appear they may not disappear again.\r\n    // For more info see issue #116\r\n    const verticalScrollBarSize =\r\n      totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\r\n    const horizontalScrollBarSize =\r\n      totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\r\n\r\n    if (\r\n      horizontalScrollBarSize !== this._horizontalScrollBarSize ||\r\n      verticalScrollBarSize !== this._verticalScrollBarSize\r\n    ) {\r\n      this._horizontalScrollBarSize = horizontalScrollBarSize;\r\n      this._verticalScrollBarSize = verticalScrollBarSize;\r\n      this._scrollbarPresenceChanged = true;\r\n    }\r\n\r\n    // Also explicitly init styles to 'auto' if scrollbars are required.\r\n    // This works around an obscure edge case where external CSS styles have not yet been loaded,\r\n    // But an initial scroll index of offset is set as an external prop.\r\n    // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\r\n    // This was originally reported via clauderic/react-infinite-calendar/issues/23\r\n    gridStyle.overflowX =\r\n      totalColumnsWidth + verticalScrollBarSize <= width ? \"hidden\" : \"auto\";\r\n    gridStyle.overflowY =\r\n      totalRowsHeight + horizontalScrollBarSize <= height ? \"hidden\" : \"auto\";\r\n\r\n    const childrenToDisplay = this._childrenToDisplay;\r\n\r\n    const showNoContentRenderer =\r\n      childrenToDisplay.length === 0 && height > 0 && width > 0;\r\n\r\n    return (\r\n      <div\r\n        ref={this._setScrollingContainerRef}\r\n        {...containerProps}\r\n        aria-label={this.props[\"aria-label\"]}\r\n        aria-readonly={this.props[\"aria-readonly\"]}\r\n        className={clsx(\"ReactVirtualized__Grid\", className)}\r\n        id={id}\r\n        onScroll={this._onScroll}\r\n        role={role}\r\n        style={{\r\n          ...gridStyle,\r\n          ...style\r\n        }}\r\n        tabIndex={tabIndex}\r\n      >\r\n        {childrenToDisplay.length > 0 && (\r\n          <div\r\n            className=\"ReactVirtualized__Grid__innerScrollContainer\"\r\n            role={containerRole}\r\n            style={{\r\n              width: autoContainerWidth ? \"auto\" : totalColumnsWidth,\r\n              height: totalRowsHeight,\r\n              maxWidth: totalColumnsWidth,\r\n              maxHeight: totalRowsHeight,\r\n              overflow: \"hidden\",\r\n              pointerEvents: isScrolling ? \"none\" : \"\",\r\n              position: \"relative\",\r\n              ...containerStyle\r\n            }}\r\n          >\r\n            {childrenToDisplay}\r\n          </div>\r\n        )}\r\n        {showNoContentRenderer && noContentRenderer()}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  /* ---------------------------- Helper methods ---------------------------- */\r\n\r\n  _calculateChildrenToRender(props = this.props, state = this.state) {\r\n    const {\r\n      cellRenderer,\r\n      cellRangeRenderer,\r\n      columnCount,\r\n      deferredMeasurementCache,\r\n      height,\r\n      overscanColumnCount,\r\n      overscanIndicesGetter,\r\n      overscanRowCount,\r\n      rowCount,\r\n      width,\r\n      isScrollingOptOut\r\n    } = props;\r\n\r\n    const {\r\n      scrollDirectionHorizontal,\r\n      scrollDirectionVertical,\r\n      instanceProps\r\n    } = state;\r\n\r\n    const scrollTop =\r\n      this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;\r\n    const scrollLeft =\r\n      this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;\r\n\r\n    const isScrolling = this._isScrolling(props, state);\r\n\r\n    this._childrenToDisplay = [];\r\n\r\n    // Render only enough columns and rows to cover the visible area of the grid.\r\n    if (height > 0 && width > 0) {\r\n      const visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange(\r\n        {\r\n          containerSize: width,\r\n          offset: scrollLeft\r\n        }\r\n      );\r\n      const visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange(\r\n        {\r\n          containerSize: height,\r\n          offset: scrollTop\r\n        }\r\n      );\r\n\r\n      const horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment(\r\n        {\r\n          containerSize: width,\r\n          offset: scrollLeft\r\n        }\r\n      );\r\n      const verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment(\r\n        {\r\n          containerSize: height,\r\n          offset: scrollTop\r\n        }\r\n      );\r\n\r\n      // Store for _invokeOnGridRenderedHelper()\r\n      this._renderedColumnStartIndex = visibleColumnIndices.start;\r\n      this._renderedColumnStopIndex = visibleColumnIndices.stop;\r\n      this._renderedRowStartIndex = visibleRowIndices.start;\r\n      this._renderedRowStopIndex = visibleRowIndices.stop;\r\n\r\n      const overscanColumnIndices = overscanIndicesGetter({\r\n        direction: \"horizontal\",\r\n        cellCount: columnCount,\r\n        overscanCellsCount: overscanColumnCount,\r\n        scrollDirection: scrollDirectionHorizontal,\r\n        startIndex:\r\n          typeof visibleColumnIndices.start === \"number\"\r\n            ? visibleColumnIndices.start\r\n            : 0,\r\n        stopIndex:\r\n          typeof visibleColumnIndices.stop === \"number\"\r\n            ? visibleColumnIndices.stop\r\n            : -1\r\n      });\r\n\r\n      const overscanRowIndices = overscanIndicesGetter({\r\n        direction: \"vertical\",\r\n        cellCount: rowCount,\r\n        overscanCellsCount: overscanRowCount,\r\n        scrollDirection: scrollDirectionVertical,\r\n        startIndex:\r\n          typeof visibleRowIndices.start === \"number\"\r\n            ? visibleRowIndices.start\r\n            : 0,\r\n        stopIndex:\r\n          typeof visibleRowIndices.stop === \"number\"\r\n            ? visibleRowIndices.stop\r\n            : -1\r\n      });\r\n\r\n      // Store for _invokeOnGridRenderedHelper()\r\n      let columnStartIndex = overscanColumnIndices.overscanStartIndex;\r\n      let columnStopIndex = overscanColumnIndices.overscanStopIndex;\r\n      let rowStartIndex = overscanRowIndices.overscanStartIndex;\r\n      let rowStopIndex = overscanRowIndices.overscanStopIndex;\r\n\r\n      // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.\r\n      if (deferredMeasurementCache) {\r\n        // If rows have a dynamic height, scan the rows we are about to render.\r\n        // If any have not yet been measured, then we need to render all columns initially,\r\n        // Because the height of the row is equal to the tallest cell within that row,\r\n        // (And so we can't know the height without measuring all column-cells first).\r\n        if (!deferredMeasurementCache.hasFixedHeight()) {\r\n          for (\r\n            let rowIndex = rowStartIndex;\r\n            rowIndex <= rowStopIndex;\r\n            rowIndex++\r\n          ) {\r\n            if (!deferredMeasurementCache.has(rowIndex, 0)) {\r\n              columnStartIndex = 0;\r\n              columnStopIndex = columnCount - 1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        // If columns have a dynamic width, scan the columns we are about to render.\r\n        // If any have not yet been measured, then we need to render all rows initially,\r\n        // Because the width of the column is equal to the widest cell within that column,\r\n        // (And so we can't know the width without measuring all row-cells first).\r\n        if (!deferredMeasurementCache.hasFixedWidth()) {\r\n          for (\r\n            let columnIndex = columnStartIndex;\r\n            columnIndex <= columnStopIndex;\r\n            columnIndex++\r\n          ) {\r\n            if (!deferredMeasurementCache.has(0, columnIndex)) {\r\n              rowStartIndex = 0;\r\n              rowStopIndex = rowCount - 1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      this._childrenToDisplay = cellRangeRenderer({\r\n        cellCache: this._cellCache,\r\n        cellRenderer,\r\n        columnSizeAndPositionManager:\r\n          instanceProps.columnSizeAndPositionManager,\r\n        columnStartIndex,\r\n        columnStopIndex,\r\n        deferredMeasurementCache,\r\n        horizontalOffsetAdjustment,\r\n        isScrolling,\r\n        isScrollingOptOut,\r\n        parent: this,\r\n        rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\r\n        rowStartIndex,\r\n        rowStopIndex,\r\n        scrollLeft,\r\n        scrollTop,\r\n        styleCache: this._styleCache,\r\n        verticalOffsetAdjustment,\r\n        visibleColumnIndices,\r\n        visibleRowIndices\r\n      });\r\n\r\n      // update the indices\r\n      this._columnStartIndex = columnStartIndex;\r\n      this._columnStopIndex = columnStopIndex;\r\n      this._rowStartIndex = rowStartIndex;\r\n      this._rowStopIndex = rowStopIndex;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets an :isScrolling flag for a small window of time.\r\n   * This flag is used to disable pointer events on the scrollable portion of the Grid.\r\n   * This prevents jerky/stuttery mouse-wheel scrolling.\r\n   */\r\n  _debounceScrollEnded() {\r\n    const { scrollingResetTimeInterval } = this.props;\r\n\r\n    if (this._disablePointerEventsTimeoutId) {\r\n      cancelAnimationTimeout(this._disablePointerEventsTimeoutId);\r\n    }\r\n\r\n    this._disablePointerEventsTimeoutId = requestAnimationTimeout(\r\n      this._debounceScrollEndedCallback,\r\n      scrollingResetTimeInterval\r\n    );\r\n  }\r\n\r\n  _debounceScrollEndedCallback = () => {\r\n    this._disablePointerEventsTimeoutId = null;\r\n    // isScrolling is used to determine if we reset styleCache\r\n    this.setState({\r\n      isScrolling: false,\r\n      needToResetStyleCache: false\r\n    });\r\n  };\r\n\r\n  static _getEstimatedColumnSize(props) {\r\n    return typeof props.columnWidth === \"number\"\r\n      ? props.columnWidth\r\n      : props.estimatedColumnSize;\r\n  }\r\n\r\n  static _getEstimatedRowSize(props) {\r\n    return typeof props.rowHeight === \"number\"\r\n      ? props.rowHeight\r\n      : props.estimatedRowSize;\r\n  }\r\n\r\n  /**\r\n   * Check for batched CellMeasurer size invalidations.\r\n   * This will occur the first time one or more previously unmeasured cells are rendered.\r\n   */\r\n  _handleInvalidatedGridSize() {\r\n    if (\r\n      typeof this._deferredInvalidateColumnIndex === \"number\" &&\r\n      typeof this._deferredInvalidateRowIndex === \"number\"\r\n    ) {\r\n      const columnIndex = this._deferredInvalidateColumnIndex;\r\n      const rowIndex = this._deferredInvalidateRowIndex;\r\n\r\n      this._deferredInvalidateColumnIndex = null;\r\n      this._deferredInvalidateRowIndex = null;\r\n\r\n      this.recomputeGridSize({ columnIndex, rowIndex });\r\n    }\r\n  }\r\n\r\n  _invokeOnGridRenderedHelper = () => {\r\n    const { onSectionRendered } = this.props;\r\n\r\n    this._onGridRenderedMemoizer({\r\n      callback: onSectionRendered,\r\n      indices: {\r\n        columnOverscanStartIndex: this._columnStartIndex,\r\n        columnOverscanStopIndex: this._columnStopIndex,\r\n        columnStartIndex: this._renderedColumnStartIndex,\r\n        columnStopIndex: this._renderedColumnStopIndex,\r\n        rowOverscanStartIndex: this._rowStartIndex,\r\n        rowOverscanStopIndex: this._rowStopIndex,\r\n        rowStartIndex: this._renderedRowStartIndex,\r\n        rowStopIndex: this._renderedRowStopIndex\r\n      }\r\n    });\r\n  };\r\n\r\n  _invokeOnScrollMemoizer({\r\n    scrollLeft,\r\n    scrollTop,\r\n    totalColumnsWidth,\r\n    totalRowsHeight\r\n  }) {\r\n    this._onScrollMemoizer({\r\n      callback: ({ scrollLeft, scrollTop }) => {\r\n        const { height, onScroll, width } = this.props;\r\n\r\n        onScroll({\r\n          clientHeight: height,\r\n          clientWidth: width,\r\n          scrollHeight: totalRowsHeight,\r\n          scrollLeft,\r\n          scrollTop,\r\n          scrollWidth: totalColumnsWidth\r\n        });\r\n      },\r\n      indices: {\r\n        scrollLeft,\r\n        scrollTop\r\n      }\r\n    });\r\n  }\r\n\r\n  _isScrolling(props = this.props, state = this.state) {\r\n    // If isScrolling is defined in props, use it to override the value in state\r\n    // This is a performance optimization for WindowScroller + Grid\r\n    return Object.hasOwnProperty.call(props, \"isScrolling\")\r\n      ? Boolean(props.isScrolling)\r\n      : Boolean(state.isScrolling);\r\n  }\r\n\r\n  _maybeCallOnScrollbarPresenceChange() {\r\n    if (this._scrollbarPresenceChanged) {\r\n      const { onScrollbarPresenceChange } = this.props;\r\n\r\n      this._scrollbarPresenceChanged = false;\r\n\r\n      onScrollbarPresenceChange({\r\n        horizontal: this._horizontalScrollBarSize > 0,\r\n        size: this.state.instanceProps.scrollbarSize,\r\n        vertical: this._verticalScrollBarSize > 0\r\n      });\r\n    }\r\n  }\r\n\r\n  _setScrollingContainerRef = ref => {\r\n    this._scrollingContainer = ref;\r\n  };\r\n\r\n  /**\r\n   * Get the updated state after scrolling to\r\n   * scrollLeft and scrollTop\r\n   */\r\n  static _getScrollToPositionStateUpdate({ prevState, scrollLeft, scrollTop }) {\r\n    const newState = {\r\n      scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\r\n    };\r\n\r\n    if (typeof scrollLeft === \"number\" && scrollLeft >= 0) {\r\n      newState.scrollDirectionHorizontal =\r\n        scrollLeft > prevState.scrollLeft\r\n          ? SCROLL_DIRECTION_FORWARD\r\n          : SCROLL_DIRECTION_BACKWARD;\r\n      newState.scrollLeft = scrollLeft;\r\n    }\r\n\r\n    if (typeof scrollTop === \"number\" && scrollTop >= 0) {\r\n      newState.scrollDirectionVertical =\r\n        scrollTop > prevState.scrollTop\r\n          ? SCROLL_DIRECTION_FORWARD\r\n          : SCROLL_DIRECTION_BACKWARD;\r\n      newState.scrollTop = scrollTop;\r\n    }\r\n\r\n    if (\r\n      (typeof scrollLeft === \"number\" &&\r\n        scrollLeft >= 0 &&\r\n        scrollLeft !== prevState.scrollLeft) ||\r\n      (typeof scrollTop === \"number\" &&\r\n        scrollTop >= 0 &&\r\n        scrollTop !== prevState.scrollTop)\r\n    ) {\r\n      return newState;\r\n    }\r\n    return {};\r\n  }\r\n\r\n  /**\r\n   * Scroll to the specified offset(s).\r\n   * Useful for animating position changes.\r\n   */\r\n  scrollToPosition({ scrollLeft, scrollTop }) {\r\n    const stateUpdate = Grid._getScrollToPositionStateUpdate({\r\n      prevState: this.state,\r\n      scrollLeft,\r\n      scrollTop\r\n    });\r\n\r\n    if (stateUpdate) {\r\n      stateUpdate.needToResetStyleCache = false;\r\n      this.setState(stateUpdate);\r\n    }\r\n  }\r\n\r\n  static _wrapSizeGetter(value) {\r\n    return typeof value === \"function\" ? value : () => value;\r\n  }\r\n\r\n  static _getCalculatedScrollLeft(nextProps, prevState) {\r\n    const {\r\n      columnCount,\r\n      height,\r\n      scrollToAlignment,\r\n      scrollToColumn,\r\n      width\r\n    } = nextProps;\r\n    const { scrollLeft, instanceProps } = prevState;\r\n\r\n    if (columnCount > 0) {\r\n      const finalColumn = columnCount - 1;\r\n      const targetIndex =\r\n        scrollToColumn < 0\r\n          ? finalColumn\r\n          : Math.min(finalColumn, scrollToColumn);\r\n      const totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\r\n      const scrollBarSize =\r\n        instanceProps.scrollbarSizeMeasured && totalRowsHeight > height\r\n          ? instanceProps.scrollbarSize\r\n          : 0;\r\n\r\n      return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex(\r\n        {\r\n          align: scrollToAlignment,\r\n          containerSize: width - scrollBarSize,\r\n          currentOffset: scrollLeft,\r\n          targetIndex\r\n        }\r\n      );\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  _getCalculatedScrollLeft(props = this.props, state = this.state) {\r\n    return Grid._getCalculatedScrollLeft(props, state);\r\n  }\r\n\r\n  static _getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState) {\r\n    const { scrollLeft } = prevState;\r\n    const calculatedScrollLeft = Grid._getCalculatedScrollLeft(\r\n      nextProps,\r\n      prevState\r\n    );\r\n\r\n    if (\r\n      typeof calculatedScrollLeft === \"number\" &&\r\n      calculatedScrollLeft >= 0 &&\r\n      scrollLeft !== calculatedScrollLeft\r\n    ) {\r\n      return Grid._getScrollToPositionStateUpdate({\r\n        prevState,\r\n        scrollLeft: calculatedScrollLeft,\r\n        scrollTop: -1\r\n      });\r\n    }\r\n    return {};\r\n  }\r\n\r\n  _updateScrollLeftForScrollToColumn(props = this.props, state = this.state) {\r\n    const stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(\r\n      props,\r\n      state\r\n    );\r\n    if (stateUpdate) {\r\n      stateUpdate.needToResetStyleCache = false;\r\n      this.setState(stateUpdate);\r\n    }\r\n  }\r\n\r\n  static _getCalculatedScrollTop(nextProps, prevState) {\r\n    const {\r\n      height,\r\n      rowCount,\r\n      scrollToAlignment,\r\n      scrollToRow,\r\n      width\r\n    } = nextProps;\r\n    const { scrollTop, instanceProps } = prevState;\r\n\r\n    if (rowCount > 0) {\r\n      const finalRow = rowCount - 1;\r\n      const targetIndex =\r\n        scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);\r\n      const totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\r\n      const scrollBarSize =\r\n        instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width\r\n          ? instanceProps.scrollbarSize\r\n          : 0;\r\n\r\n      return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({\r\n        align: scrollToAlignment,\r\n        containerSize: height - scrollBarSize,\r\n        currentOffset: scrollTop,\r\n        targetIndex\r\n      });\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  _getCalculatedScrollTop(props = this.props, state = this.state) {\r\n    return Grid._getCalculatedScrollTop(props, state);\r\n  }\r\n\r\n  _resetStyleCache() {\r\n    const styleCache = this._styleCache;\r\n    const cellCache = this._cellCache;\r\n    const { isScrollingOptOut } = this.props;\r\n\r\n    // Reset cell and style caches once scrolling stops.\r\n    // This makes Grid simpler to use (since cells commonly change).\r\n    // And it keeps the caches from growing too large.\r\n    // Performance is most sensitive when a user is scrolling.\r\n    // Don't clear visible cells from cellCache if isScrollingOptOut is specified.\r\n    // This keeps the cellCache to a resonable size.\r\n    this._cellCache = {};\r\n    this._styleCache = {};\r\n\r\n    // Copy over the visible cell styles so avoid unnecessary re-render.\r\n    for (\r\n      let rowIndex = this._rowStartIndex;\r\n      rowIndex <= this._rowStopIndex;\r\n      rowIndex++\r\n    ) {\r\n      for (\r\n        let columnIndex = this._columnStartIndex;\r\n        columnIndex <= this._columnStopIndex;\r\n        columnIndex++\r\n      ) {\r\n        let key = `${rowIndex}-${columnIndex}`;\r\n        this._styleCache[key] = styleCache[key];\r\n\r\n        if (isScrollingOptOut) {\r\n          this._cellCache[key] = cellCache[key];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  static _getScrollTopForScrollToRowStateUpdate(nextProps, prevState) {\r\n    const { scrollTop } = prevState;\r\n    const calculatedScrollTop = Grid._getCalculatedScrollTop(\r\n      nextProps,\r\n      prevState\r\n    );\r\n\r\n    if (\r\n      typeof calculatedScrollTop === \"number\" &&\r\n      calculatedScrollTop >= 0 &&\r\n      scrollTop !== calculatedScrollTop\r\n    ) {\r\n      return Grid._getScrollToPositionStateUpdate({\r\n        prevState,\r\n        scrollLeft: -1,\r\n        scrollTop: calculatedScrollTop\r\n      });\r\n    }\r\n    return {};\r\n  }\r\n\r\n  _updateScrollTopForScrollToRow(props = this.props, state = this.state) {\r\n    const stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(\r\n      props,\r\n      state\r\n    );\r\n    if (stateUpdate) {\r\n      stateUpdate.needToResetStyleCache = false;\r\n      this.setState(stateUpdate);\r\n    }\r\n  }\r\n\r\n  _onScroll = event => {\r\n    // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\r\n    // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\r\n    // See issue #404 for more information.\r\n    if (event.target === this._scrollingContainer) {\r\n      this.handleScrollEvent(event.target);\r\n    }\r\n  };\r\n}\r\n\r\npolyfill(Grid);\r\nexport default Grid;\r\n","// @flow\r\n\r\nimport type {OverscanIndicesGetterParams, OverscanIndices} from './types';\r\n\r\nexport const SCROLL_DIRECTION_BACKWARD = -1;\r\nexport const SCROLL_DIRECTION_FORWARD = 1;\r\n\r\nexport const SCROLL_DIRECTION_HORIZONTAL = 'horizontal';\r\nexport const SCROLL_DIRECTION_VERTICAL = 'vertical';\r\n\r\n/**\r\n * Calculates the number of cells to overscan before and after a specified range.\r\n * This function ensures that overscanning doesn't exceed the available cells.\r\n */\r\n\r\nexport default function defaultOverscanIndicesGetter({\r\n  cellCount,\r\n  overscanCellsCount,\r\n  scrollDirection,\r\n  startIndex,\r\n  stopIndex,\r\n}: OverscanIndicesGetterParams): OverscanIndices {\r\n  if (scrollDirection === SCROLL_DIRECTION_FORWARD) {\r\n    return {\r\n      overscanStartIndex: Math.max(0, startIndex),\r\n      overscanStopIndex: Math.min(\r\n        cellCount - 1,\r\n        stopIndex + overscanCellsCount,\r\n      ),\r\n    };\r\n  } else {\r\n    return {\r\n      overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),\r\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex),\r\n    };\r\n  }\r\n}\r\n","/** @flow */\r\n\r\nimport type {CellRangeRendererParams} from './types';\r\n\r\n/**\r\n * Default implementation of cellRangeRenderer used by Grid.\r\n * This renderer supports cell-caching while the user is scrolling.\r\n */\r\n\r\nexport default function defaultCellRangeRenderer({\r\n  cellCache,\r\n  cellRenderer,\r\n  columnSizeAndPositionManager,\r\n  columnStartIndex,\r\n  columnStopIndex,\r\n  deferredMeasurementCache,\r\n  horizontalOffsetAdjustment,\r\n  isScrolling,\r\n  isScrollingOptOut,\r\n  parent, // Grid (or List or Table)\r\n  rowSizeAndPositionManager,\r\n  rowStartIndex,\r\n  rowStopIndex,\r\n  styleCache,\r\n  verticalOffsetAdjustment,\r\n  visibleColumnIndices,\r\n  visibleRowIndices,\r\n}: CellRangeRendererParams) {\r\n  const renderedCells = [];\r\n\r\n  // Browsers have native size limits for elements (eg Chrome 33M pixels, IE 1.5M pixes).\r\n  // User cannot scroll beyond these size limitations.\r\n  // In order to work around this, ScalingCellSizeAndPositionManager compresses offsets.\r\n  // We should never cache styles for compressed offsets though as this can lead to bugs.\r\n  // See issue #576 for more.\r\n  const areOffsetsAdjusted =\r\n    columnSizeAndPositionManager.areOffsetsAdjusted() ||\r\n    rowSizeAndPositionManager.areOffsetsAdjusted();\r\n\r\n  const canCacheStyle = !isScrolling && !areOffsetsAdjusted;\r\n\r\n  for (let rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\r\n    let rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex);\r\n\r\n    for (\r\n      let columnIndex = columnStartIndex;\r\n      columnIndex <= columnStopIndex;\r\n      columnIndex++\r\n    ) {\r\n      let columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(\r\n        columnIndex,\r\n      );\r\n      let isVisible =\r\n        columnIndex >= visibleColumnIndices.start &&\r\n        columnIndex <= visibleColumnIndices.stop &&\r\n        rowIndex >= visibleRowIndices.start &&\r\n        rowIndex <= visibleRowIndices.stop;\r\n      let key = `${rowIndex}-${columnIndex}`;\r\n      let style;\r\n\r\n      // Cache style objects so shallow-compare doesn't re-render unnecessarily.\r\n      if (canCacheStyle && styleCache[key]) {\r\n        style = styleCache[key];\r\n      } else {\r\n        // In deferred mode, cells will be initially rendered before we know their size.\r\n        // Don't interfere with CellMeasurer's measurements by setting an invalid size.\r\n        if (\r\n          deferredMeasurementCache &&\r\n          !deferredMeasurementCache.has(rowIndex, columnIndex)\r\n        ) {\r\n          // Position not-yet-measured cells at top/left 0,0,\r\n          // And give them width/height of 'auto' so they can grow larger than the parent Grid if necessary.\r\n          // Positioning them further to the right/bottom influences their measured size.\r\n          style = {\r\n            height: 'auto',\r\n            left: 0,\r\n            position: 'absolute',\r\n            top: 0,\r\n            width: 'auto',\r\n          };\r\n        } else {\r\n          style = {\r\n            height: rowDatum.size,\r\n            left: columnDatum.offset + horizontalOffsetAdjustment,\r\n            position: 'absolute',\r\n            top: rowDatum.offset + verticalOffsetAdjustment,\r\n            width: columnDatum.size,\r\n          };\r\n\r\n          styleCache[key] = style;\r\n        }\r\n      }\r\n\r\n      let cellRendererParams = {\r\n        columnIndex,\r\n        isScrolling,\r\n        isVisible,\r\n        key,\r\n        parent,\r\n        rowIndex,\r\n        style,\r\n      };\r\n\r\n      let renderedCell;\r\n\r\n      // Avoid re-creating cells while scrolling.\r\n      // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\r\n      // If a scroll is in progress- cache and reuse cells.\r\n      // This cache will be thrown away once scrolling completes.\r\n      // However if we are scaling scroll positions and sizes, we should also avoid caching.\r\n      // This is because the offset changes slightly as scroll position changes and caching leads to stale values.\r\n      // For more info refer to issue #395\r\n      //\r\n      // If isScrollingOptOut is specified, we always cache cells.\r\n      // For more info refer to issue #1028\r\n      if (\r\n        (isScrollingOptOut || isScrolling) &&\r\n        !horizontalOffsetAdjustment &&\r\n        !verticalOffsetAdjustment\r\n      ) {\r\n        if (!cellCache[key]) {\r\n          cellCache[key] = cellRenderer(cellRendererParams);\r\n        }\r\n\r\n        renderedCell = cellCache[key];\r\n\r\n        // If the user is no longer scrolling, don't cache cells.\r\n        // This makes dynamic cell content difficult for users and would also lead to a heavier memory footprint.\r\n      } else {\r\n        renderedCell = cellRenderer(cellRendererParams);\r\n      }\r\n\r\n      if (renderedCell == null || renderedCell === false) {\r\n        continue;\r\n      }\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        warnAboutMissingStyle(parent, renderedCell);\r\n      }\r\n\r\n      renderedCells.push(renderedCell);\r\n    }\r\n  }\r\n\r\n  return renderedCells;\r\n}\r\n\r\nfunction warnAboutMissingStyle(parent, renderedCell) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (renderedCell) {\r\n      // If the direct child is a CellMeasurer, then we should check its child\r\n      // See issue #611\r\n      if (renderedCell.type && renderedCell.type.__internalCellMeasurerFlag) {\r\n        renderedCell = renderedCell.props.children;\r\n      }\r\n\r\n      if (\r\n        renderedCell &&\r\n        renderedCell.props &&\r\n        renderedCell.props.style === undefined &&\r\n        parent.__warnedAboutMissingStyle !== true\r\n      ) {\r\n        parent.__warnedAboutMissingStyle = true;\r\n\r\n        console.warn(\r\n          'Rendered cell should include style property for positioning.',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n","import * as React from \"react\";\r\nimport clsx from \"clsx\";\r\n\r\nimport {\r\n  ContentBox,\r\n  ContentBoxHeader,\r\n  ContentBoxParagraph\r\n} from \"../demo/ContentBox\";\r\nimport ArrowKeyStepper from \"./\";\r\nimport AutoSizer from \"../AutoSizer\";\r\nimport Grid from \"../Grid\";\r\nimport styles from \"./ArrowKeyStepper.module.css\";\r\n\r\nexport default class ArrowKeyStepperExample extends React.PureComponent {\r\n  state = {\r\n    mode: \"cells\",\r\n    isMouseDown: false,\r\n    isClickable: true,\r\n    scrollToColumn: 0,\r\n    scrollToRow: 0,\r\n    startCellIndex: 0,\r\n    startRowIndex: 0,\r\n    selectedItems: []\r\n  };\r\n\r\n  selectTo = (event, rowIndex, columnIndex) => {\r\n    let rowStart = null;\r\n    let rowEnd = null;\r\n    let cellStart = null;\r\n    let cellEnd = null;\r\n\r\n    if (rowIndex < this.state.startRowIndex) {\r\n      rowStart = rowIndex;\r\n      rowEnd = this.state.startRowIndex;\r\n    } else {\r\n      rowStart = this.state.startRowIndex;\r\n      rowEnd = rowIndex;\r\n    }\r\n\r\n    if (columnIndex < this.state.startCellIndex) {\r\n      cellStart = columnIndex;\r\n      cellEnd = this.state.startCellIndex;\r\n    } else {\r\n      cellStart = this.state.startCellIndex;\r\n      cellEnd = columnIndex;\r\n    }\r\n\r\n    let result = [];\r\n\r\n    for (let i = rowStart; i <= rowEnd; i += 1) {\r\n      for (let j = cellStart; j <= cellEnd; j += 1) {\r\n        result.push({\r\n          r: i,\r\n          c: j\r\n        });\r\n      }\r\n    }\r\n    this.setState({\r\n      selectedItems: result\r\n    });\r\n  };\r\n\r\n  handleMouseUp = () => {\r\n    this.setState({\r\n      isMouseDown: false\r\n    });\r\n  };\r\n\r\n  mouseDown = (event, rowIndex, columnIndex) => {\r\n    if (event.button === 0) {\r\n      this.setState({\r\n        isMouseDown: true,\r\n        startCellIndex: columnIndex,\r\n        startRowIndex: rowIndex,\r\n        selectedItems: []\r\n      });\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  mouseOver = (event, rowIndex, columnIndex) => {\r\n    if (!this.state.isMouseDown) return;\r\n    this.selectTo(event.target, rowIndex, columnIndex);\r\n  };\r\n\r\n  render() {\r\n    const { mode, isClickable, scrollToColumn, scrollToRow } = this.state;\r\n\r\n    return (\r\n      <ContentBox>\r\n        <ContentBoxHeader\r\n          text=\"This demo using ArrowKeyStepper\"\r\n          sourceLink=\"https://bvaughn.github.io/react-virtualized/#/components/ArrowKeyStepper\"\r\n        />\r\n\r\n        <ArrowKeyStepper\r\n          onMouseUp={this.handleMouseUp}\r\n          columnCount={100}\r\n          isControlled={isClickable}\r\n          onScrollToChange={isClickable ? this._selectCell : undefined}\r\n          mode={mode}\r\n          rowCount={1000}\r\n          scrollToColumn={scrollToColumn}\r\n          scrollToRow={scrollToRow}\r\n        >\r\n          {({ onSectionRendered, scrollToColumn, scrollToRow }) => (\r\n            <div>\r\n              <ContentBoxParagraph>\r\n                {`Most-recently-stepped column: ${scrollToColumn}, row: ${scrollToRow}`}\r\n              </ContentBoxParagraph>\r\n\r\n              <AutoSizer disableHeight>\r\n                {({ width }) => (\r\n                  <Grid\r\n                    className={styles.Grid}\r\n                    columnWidth={this._getColumnWidth}\r\n                    columnCount={100}\r\n                    height={500}\r\n                    onSectionRendered={onSectionRendered}\r\n                    cellRenderer={({ columnIndex, key, rowIndex, style }) =>\r\n                      this._cellRenderer({\r\n                        columnIndex,\r\n                        key,\r\n                        rowIndex,\r\n                        scrollToColumn,\r\n                        scrollToRow,\r\n                        style\r\n                      })\r\n                    }\r\n                    rowHeight={this._getRowHeight}\r\n                    rowCount={100}\r\n                    scrollToColumn={scrollToColumn}\r\n                    scrollToRow={scrollToRow}\r\n                    width={width}\r\n                  />\r\n                )}\r\n              </AutoSizer>\r\n            </div>\r\n          )}\r\n        </ArrowKeyStepper>\r\n      </ContentBox>\r\n    );\r\n  }\r\n\r\n  _getColumnWidth = ({ index }) => {\r\n    return (1 + (index % 3)) * 60;\r\n  };\r\n\r\n  _getRowHeight = ({ index }) => {\r\n    return (1 + (index % 3)) * 30;\r\n  };\r\n\r\n  compare = (rowIndex, columnIndex) => {\r\n    const { selectedItems } = this.state;\r\n    return selectedItems.length <=1 ? false : selectedItems.some(item => {\r\n      return item.r === rowIndex && item.c === columnIndex;\r\n    });\r\n  };\r\n\r\n  _cellRenderer = ({\r\n    columnIndex,\r\n    key,\r\n    rowIndex,\r\n    scrollToColumn,\r\n    scrollToRow,\r\n    style\r\n  }) => {\r\n    const className = clsx(styles.Cell, {\r\n      [styles.FocusedCell]:\r\n        columnIndex === scrollToColumn && rowIndex === scrollToRow,\r\n      [styles.selected]: this.compare(rowIndex, columnIndex)\r\n    });\r\n\r\n    return (\r\n      <span\r\n        role=\"none\"\r\n        onMouseDown={e => this.mouseDown(e, rowIndex, columnIndex)}\r\n        onMouseOver={e => this.mouseOver(e, rowIndex, columnIndex)}\r\n        className={className}\r\n        key={key}\r\n        onClick={\r\n          this.state.isClickable &&\r\n          (() =>\r\n            this._selectCell({\r\n              scrollToColumn: columnIndex,\r\n              scrollToRow: rowIndex\r\n            }))\r\n        }\r\n        style={style}\r\n      >\r\n        {`r:${rowIndex}, c:${columnIndex}`}\r\n      </span>\r\n    );\r\n  };\r\n\r\n  _selectCell = ({ scrollToColumn, scrollToRow }) => {\r\n    this.setState({ scrollToColumn, scrollToRow });\r\n  };\r\n}\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\nimport ArrowKeyStepperExample from \"./ArrowKeyStepper/ArrowKeyStepper.example\";\r\n\r\nfunction App() {\r\n  return (\r\n    <div style={{ textAlign: \"center\" }}>\r\n      <ArrowKeyStepperExample />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}